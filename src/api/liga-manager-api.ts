/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * Returns a list of latest events
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param type (optional) 
     * @return Array of events
     */
    getLatestEvents(start_date?: Date | null | undefined, end_date?: Date | null | undefined, type?: string | null | undefined): Observable<Event[]>;
    /**
     * Returns a single event
     * @return An event object
     */
    getEvent(id: string): Observable<Event>;
    /**
     * Find matches by multiple filter criteria
     * @param season_id (optional) 
     * @param tournament_id (optional) 
     * @param team_id (optional) 
     * @param match_day_id (optional) 
     * @return Array of matches
     */
    getMatches(season_id?: string | null | undefined, tournament_id?: string | null | undefined, team_id?: string | null | undefined, match_day_id?: string | null | undefined): Observable<Match[]>;
    /**
     * Find a single match by id
     * @param id match id
     * @return Contains a single match object
     */
    getMatch(id: string): Observable<Match>;
    /**
     * Cancel a match
     * @param id match id
     * @param cancelMatchBody (optional) 
     * @return Operation successful
     */
    cancelMatch(id: string, cancelMatchBody?: CancelMatchBody | null | undefined): Observable<void>;
    /**
     * Schedule a match
     * @param id match id
     * @param scheduleMatchBody (optional) 
     * @return Operation successful
     */
    scheduleMatch(id: string, scheduleMatchBody?: ScheduleMatchBody | null | undefined): Observable<void>;
    /**
     * Locate a match on a pitch
     * @param id match id
     * @param locateMatchBody (optional) 
     * @return Operation successful
     */
    locateMatch(id: string, locateMatchBody?: LocateMatchBody | null | undefined): Observable<void>;
    /**
     * Submit a matches result
     * @param id match id
     * @param submitMatchResultBody (optional) 
     * @return Operation successful
     */
    submitMatchResult(id: string, submitMatchResultBody?: SubmitMatchResultBody | null | undefined): Observable<void>;
    /**
     * Reschedules a matchday
     * @param id matchday id
     * @param scheduleMatchDayBody (optional) 
     * @return Operation successful
     */
    rescheduleMatchDay(id: string, scheduleMatchDayBody?: ScheduleMatchDayBody | null | undefined): Observable<void>;
    /**
     * Find all pitches
     * @return Array of pitches
     */
    getAllPitches(): Observable<Pitch[]>;
    /**
     * Creates a new pitch
     * @param createPitchBody (optional) 
     * @return Operation successful
     */
    createPitch(createPitchBody?: CreatePitchBody | null | undefined): Observable<Identifier>;
    /**
     * Delete a single pitch
     * @param id pitch id
     * @return Deletion successful
     */
    deletePitch(id: string): Observable<void>;
    /**
     * Find a single pitch by id
     * @param id pitch id
     * @return Contains a single pitch object
     */
    getPitch(id: string): Observable<Pitch>;
    /**
     * Updates the contact person of a pitch
     * @param id ID of pitch
     * @param updatePitchContactBody (optional) 
     * @return Pitch contact has been modified successfully
     */
    updatePitchContact(id: string, updatePitchContactBody?: Contact_person | null | undefined): Observable<void>;
    /**
     * Find all seasons
     * @return List of seasons
     */
    getAllSeasons(): Observable<Season[]>;
    /**
     * Create a new season
     * @param createSeasonBody (optional) 
     * @return Operation successful
     */
    createSeason(createSeasonBody?: CreateSeasonBody | null | undefined): Observable<Identifier>;
    /**
     * Delete a single season
     * @param id ID of season
     * @return Deletion successful
     */
    deleteSeason(id: string): Observable<void>;
    /**
     * Finds a single season
     * @param id ID of season
     * @return Contains a single season object
     */
    getSeason(id: string): Observable<Season>;
    /**
     * Find season matchdays
     * @param id ID of season
     * @return Array of matchdays
     */
    getMatchDaysInSeason(id: string): Observable<Match_day[]>;
    /**
     * Creates matchdays & matches for a given season
     * @param id ID of season
     * @param createMatchDaysBody (optional) 
     * @return Operation successful
     */
    createMatchDays(id: string, createMatchDaysBody?: CreateMatchDaysBody | null | undefined): Observable<void>;
    /**
     * Returns the current season ranking
     * @param id ID of season
     * @return Current season ranking
     */
    getRanking(id: string): Observable<Ranking>;
    /**
     * Creates a ranking penalty for a team
     * @param season_id ID of season
     * @param createRankingPenaltyBody (optional) 
     * @return Operation successful
     */
    createRankingPenalty(season_id: string, createRankingPenaltyBody?: CreateRankingPenaltyBody | null | undefined): Observable<Identifier>;
    /**
     * Deletes a ranking penalty
     * @param season_id ID of season
     * @param penalty_id ID of ranking penalty
     * @return Operation successful
     */
    deleteRankingPenalty(season_id: string, penalty_id: string): Observable<void>;
    /**
     * Starts a season
     * @param id ID of season
     * @return Season has been successfully started
     */
    startSeason(id: string): Observable<void>;
    /**
     * Ends a season
     * @param id ID of season
     * @return Operation successful
     */
    endSeason(id: string): Observable<void>;
    /**
     * Find all teams related to a single season
     * @param id ID of season
     * @return Array of teams related to the season
     */
    getTeamsInSeason(id: string): Observable<Team[]>;
    /**
     * Add a team to a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    addTeamToSeason(season_id: string, team_id: string): Observable<void>;
    /**
     * Remove a team from a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    removeTeamFromSeason(season_id: string, team_id: string): Observable<void>;
    /**
     * Finds all teams
     * @return list of teams
     */
    getAllTeams(): Observable<Team[]>;
    /**
     * Creates a new team
     * @param createTeamBody (optional) 
     * @return Operation successful
     */
    createTeam(createTeamBody?: CreateTeamBody | null | undefined): Observable<Identifier>;
    /**
     * Delete a single team by id
     * @param id ID of team
     * @return Deletion successful
     */
    deleteTeam(id: string): Observable<void>;
    /**
     * Finds a single team by id
     * @param id ID of team
     * @return Single team
     */
    getTeam(id: string): Observable<Team>;
    /**
     * Renames a team
     * @param id ID of team
     * @param renameTeamBody (optional) 
     * @return Operation successful
     */
    renameTeam(id: string, renameTeamBody?: RenameTeamBody | null | undefined): Observable<void>;
    /**
     * Updates the contact person of team
     * @param id ID of team
     * @param updateTeamContactBody (optional) 
     * @return Team contact has been modified successfully
     */
    updateTeamContact(id: string, updateTeamContactBody?: Contact_person | null | undefined): Observable<void>;
    /**
     * Finds all tournaments
     * @return List of tournaments
     */
    getAllTournaments(): Observable<Tournament[]>;
    /**
     * Creates a new tournament
     * @param createTournamentBody (optional) 
     * @return Operation successful
     */
    createTournament(createTournamentBody?: CreateTournamentBody | null | undefined): Observable<Identifier>;
    /**
     * Find a single tournament by id
     * @param id ID of tournament
     * @return Single tournament
     */
    getTournament(id: string): Observable<Tournament>;
    /**
     * Delete a single tournament by id
     * @param id ID of tournament
     * @return Operation successful
     */
    deleteTournament(id: string): Observable<void>;
    /**
     * Defines a set of team pairings as a tournament round
     * @param id ID of tournament
     * @param round Number identifying the tournament round
     * @param setRoundBody (optional) 
     * @return Operation successful
     */
    setRound(id: string, round: number, setRoundBody?: SetRoundBody | null | undefined): Observable<void>;
    /**
     * Finds all rounds for a tournament
     * @param id ID of tournament
     * @return Array of rounds
     */
    getRoundsInTournament(id: string): Observable<Match_day[]>;
    /**
     * Find all users
     * @return Array of users
     */
    getAllUsers(): Observable<void>;
    /**
     * Create a user
     * @param createUserBody (optional) 
     * @return Operation successful
     */
    createUser(createUserBody?: CreateUserBody | null | undefined): Observable<void>;
    /**
     * Retrieve the authenticated user
     * @return The authenticated user as object
     */
    getAuthenticatedUser(): Observable<User>;
    /**
     * Change the authenticated user's password
     * @param changePasswordBody (optional) 
     * @return Operation successful
     */
    changePassword(changePasswordBody?: ChangePasswordBody | null | undefined): Observable<void>;
    /**
     * Sends a password reset mail for the user with the given email address
     * @param sendPasswordResetMailBody (optional) 
     * @return Operation successful
     */
    sendPasswordResetMail(sendPasswordResetMailBody?: SendPasswordResetMailBody | null | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * Returns a list of latest events
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param type (optional) 
     * @return Array of events
     */
    getLatestEvents(start_date?: Date | null | undefined, end_date?: Date | null | undefined, type?: string | null | undefined): Observable<Event[]> {
        let url_ = this.baseUrl + "/events?";
        if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toJSON() : "") + "&"; 
        if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toJSON() : "") + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestEvents(<any>response_);
                } catch (e) {
                    return <Observable<Event[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Event[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestEvents(response: HttpResponseBase): Observable<Event[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Event.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Event[]>(<any>null);
    }

    /**
     * Returns a single event
     * @return An event object
     */
    getEvent(id: string): Observable<Event> {
        let url_ = this.baseUrl + "/events/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvent(<any>response_);
                } catch (e) {
                    return <Observable<Event>><any>_observableThrow(e);
                }
            } else
                return <Observable<Event>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvent(response: HttpResponseBase): Observable<Event> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Event.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Event>(<any>null);
    }

    /**
     * Find matches by multiple filter criteria
     * @param season_id (optional) 
     * @param tournament_id (optional) 
     * @param team_id (optional) 
     * @param match_day_id (optional) 
     * @return Array of matches
     */
    getMatches(season_id?: string | null | undefined, tournament_id?: string | null | undefined, team_id?: string | null | undefined, match_day_id?: string | null | undefined): Observable<Match[]> {
        let url_ = this.baseUrl + "/matches?";
        if (season_id !== undefined)
            url_ += "season_id=" + encodeURIComponent("" + season_id) + "&"; 
        if (tournament_id !== undefined)
            url_ += "tournament_id=" + encodeURIComponent("" + tournament_id) + "&"; 
        if (team_id !== undefined)
            url_ += "team_id=" + encodeURIComponent("" + team_id) + "&"; 
        if (match_day_id !== undefined)
            url_ += "match_day_id=" + encodeURIComponent("" + match_day_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatches(<any>response_);
                } catch (e) {
                    return <Observable<Match[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Match[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatches(response: HttpResponseBase): Observable<Match[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Match.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Match[]>(<any>null);
    }

    /**
     * Find a single match by id
     * @param id match id
     * @return Contains a single match object
     */
    getMatch(id: string): Observable<Match> {
        let url_ = this.baseUrl + "/matches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatch(<any>response_);
                } catch (e) {
                    return <Observable<Match>><any>_observableThrow(e);
                }
            } else
                return <Observable<Match>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatch(response: HttpResponseBase): Observable<Match> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Match.fromJS(resultData200) : new Match();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Match>(<any>null);
    }

    /**
     * Cancel a match
     * @param id match id
     * @param cancelMatchBody (optional) 
     * @return Operation successful
     */
    cancelMatch(id: string, cancelMatchBody?: CancelMatchBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/matches/{id}/cancellation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cancelMatchBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelMatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelMatch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelMatch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Schedule a match
     * @param id match id
     * @param scheduleMatchBody (optional) 
     * @return Operation successful
     */
    scheduleMatch(id: string, scheduleMatchBody?: ScheduleMatchBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/matches/{id}/kickoff";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleMatchBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleMatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleMatch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleMatch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Locate a match on a pitch
     * @param id match id
     * @param locateMatchBody (optional) 
     * @return Operation successful
     */
    locateMatch(id: string, locateMatchBody?: LocateMatchBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/matches/{id}/location";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(locateMatchBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocateMatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocateMatch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLocateMatch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Submit a matches result
     * @param id match id
     * @param submitMatchResultBody (optional) 
     * @return Operation successful
     */
    submitMatchResult(id: string, submitMatchResultBody?: SubmitMatchResultBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/matches/{id}/result";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(submitMatchResultBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMatchResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMatchResult(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitMatchResult(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Reschedules a matchday
     * @param id matchday id
     * @param scheduleMatchDayBody (optional) 
     * @return Operation successful
     */
    rescheduleMatchDay(id: string, scheduleMatchDayBody?: ScheduleMatchDayBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/match_days/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleMatchDayBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRescheduleMatchDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRescheduleMatchDay(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRescheduleMatchDay(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Find all pitches
     * @return Array of pitches
     */
    getAllPitches(): Observable<Pitch[]> {
        let url_ = this.baseUrl + "/pitches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPitches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPitches(<any>response_);
                } catch (e) {
                    return <Observable<Pitch[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pitch[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPitches(response: HttpResponseBase): Observable<Pitch[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pitch.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pitch[]>(<any>null);
    }

    /**
     * Creates a new pitch
     * @param createPitchBody (optional) 
     * @return Operation successful
     */
    createPitch(createPitchBody?: CreatePitchBody | null | undefined): Observable<Identifier> {
        let url_ = this.baseUrl + "/pitches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createPitchBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePitch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePitch(<any>response_);
                } catch (e) {
                    return <Observable<Identifier>><any>_observableThrow(e);
                }
            } else
                return <Observable<Identifier>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePitch(response: HttpResponseBase): Observable<Identifier> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Identifier>(<any>null);
    }

    /**
     * Delete a single pitch
     * @param id pitch id
     * @return Deletion successful
     */
    deletePitch(id: string): Observable<void> {
        let url_ = this.baseUrl + "/pitches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePitch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePitch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePitch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Find a single pitch by id
     * @param id pitch id
     * @return Contains a single pitch object
     */
    getPitch(id: string): Observable<Pitch> {
        let url_ = this.baseUrl + "/pitches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPitch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPitch(<any>response_);
                } catch (e) {
                    return <Observable<Pitch>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pitch>><any>_observableThrow(response_);
        }));
    }

    protected processGetPitch(response: HttpResponseBase): Observable<Pitch> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Pitch.fromJS(resultData200) : new Pitch();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pitch>(<any>null);
    }

    /**
     * Updates the contact person of a pitch
     * @param id ID of pitch
     * @param updatePitchContactBody (optional) 
     * @return Pitch contact has been modified successfully
     */
    updatePitchContact(id: string, updatePitchContactBody?: Contact_person | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/pitches/{id}/contact";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatePitchContactBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePitchContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePitchContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePitchContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Find all seasons
     * @return List of seasons
     */
    getAllSeasons(): Observable<Season[]> {
        let url_ = this.baseUrl + "/seasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSeasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSeasons(<any>response_);
                } catch (e) {
                    return <Observable<Season[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Season[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSeasons(response: HttpResponseBase): Observable<Season[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Season.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Season[]>(<any>null);
    }

    /**
     * Create a new season
     * @param createSeasonBody (optional) 
     * @return Operation successful
     */
    createSeason(createSeasonBody?: CreateSeasonBody | null | undefined): Observable<Identifier> {
        let url_ = this.baseUrl + "/seasons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createSeasonBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSeason(<any>response_);
                } catch (e) {
                    return <Observable<Identifier>><any>_observableThrow(e);
                }
            } else
                return <Observable<Identifier>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSeason(response: HttpResponseBase): Observable<Identifier> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Identifier>(<any>null);
    }

    /**
     * Delete a single season
     * @param id ID of season
     * @return Deletion successful
     */
    deleteSeason(id: string): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSeason(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSeason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Finds a single season
     * @param id ID of season
     * @return Contains a single season object
     */
    getSeason(id: string): Observable<Season> {
        let url_ = this.baseUrl + "/seasons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSeason(<any>response_);
                } catch (e) {
                    return <Observable<Season>><any>_observableThrow(e);
                }
            } else
                return <Observable<Season>><any>_observableThrow(response_);
        }));
    }

    protected processGetSeason(response: HttpResponseBase): Observable<Season> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Season.fromJS(resultData200) : new Season();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Season>(<any>null);
    }

    /**
     * Find season matchdays
     * @param id ID of season
     * @return Array of matchdays
     */
    getMatchDaysInSeason(id: string): Observable<Match_day[]> {
        let url_ = this.baseUrl + "/seasons/{id}/match_days";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchDaysInSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchDaysInSeason(<any>response_);
                } catch (e) {
                    return <Observable<Match_day[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Match_day[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchDaysInSeason(response: HttpResponseBase): Observable<Match_day[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Match_day.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Match_day[]>(<any>null);
    }

    /**
     * Creates matchdays & matches for a given season
     * @param id ID of season
     * @param createMatchDaysBody (optional) 
     * @return Operation successful
     */
    createMatchDays(id: string, createMatchDaysBody?: CreateMatchDaysBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{id}/match_days";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createMatchDaysBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMatchDays(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMatchDays(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMatchDays(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Returns the current season ranking
     * @param id ID of season
     * @return Current season ranking
     */
    getRanking(id: string): Observable<Ranking> {
        let url_ = this.baseUrl + "/seasons/{id}/ranking";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRanking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRanking(<any>response_);
                } catch (e) {
                    return <Observable<Ranking>><any>_observableThrow(e);
                }
            } else
                return <Observable<Ranking>><any>_observableThrow(response_);
        }));
    }

    protected processGetRanking(response: HttpResponseBase): Observable<Ranking> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Ranking.fromJS(resultData200) : new Ranking();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Ranking>(<any>null);
    }

    /**
     * Creates a ranking penalty for a team
     * @param season_id ID of season
     * @param createRankingPenaltyBody (optional) 
     * @return Operation successful
     */
    createRankingPenalty(season_id: string, createRankingPenaltyBody?: CreateRankingPenaltyBody | null | undefined): Observable<Identifier> {
        let url_ = this.baseUrl + "/seasons/{season_id}/ranking/penalties";
        if (season_id === undefined || season_id === null)
            throw new Error("The parameter 'season_id' must be defined.");
        url_ = url_.replace("{season_id}", encodeURIComponent("" + season_id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRankingPenaltyBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRankingPenalty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRankingPenalty(<any>response_);
                } catch (e) {
                    return <Observable<Identifier>><any>_observableThrow(e);
                }
            } else
                return <Observable<Identifier>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRankingPenalty(response: HttpResponseBase): Observable<Identifier> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Identifier>(<any>null);
    }

    /**
     * Deletes a ranking penalty
     * @param season_id ID of season
     * @param penalty_id ID of ranking penalty
     * @return Operation successful
     */
    deleteRankingPenalty(season_id: string, penalty_id: string): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{season_id}/ranking/penalties/{penalty_id}";
        if (season_id === undefined || season_id === null)
            throw new Error("The parameter 'season_id' must be defined.");
        url_ = url_.replace("{season_id}", encodeURIComponent("" + season_id)); 
        if (penalty_id === undefined || penalty_id === null)
            throw new Error("The parameter 'penalty_id' must be defined.");
        url_ = url_.replace("{penalty_id}", encodeURIComponent("" + penalty_id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRankingPenalty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRankingPenalty(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRankingPenalty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Starts a season
     * @param id ID of season
     * @return Season has been successfully started
     */
    startSeason(id: string): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{id}/start";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartSeason(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartSeason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Ends a season
     * @param id ID of season
     * @return Operation successful
     */
    endSeason(id: string): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{id}/end";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndSeason(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEndSeason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Find all teams related to a single season
     * @param id ID of season
     * @return Array of teams related to the season
     */
    getTeamsInSeason(id: string): Observable<Team[]> {
        let url_ = this.baseUrl + "/seasons/{id}/teams";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamsInSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamsInSeason(<any>response_);
                } catch (e) {
                    return <Observable<Team[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Team[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeamsInSeason(response: HttpResponseBase): Observable<Team[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Team.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Team[]>(<any>null);
    }

    /**
     * Add a team to a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    addTeamToSeason(season_id: string, team_id: string): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{season_id}/teams/{team_id}";
        if (season_id === undefined || season_id === null)
            throw new Error("The parameter 'season_id' must be defined.");
        url_ = url_.replace("{season_id}", encodeURIComponent("" + season_id)); 
        if (team_id === undefined || team_id === null)
            throw new Error("The parameter 'team_id' must be defined.");
        url_ = url_.replace("{team_id}", encodeURIComponent("" + team_id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTeamToSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTeamToSeason(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddTeamToSeason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Remove a team from a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    removeTeamFromSeason(season_id: string, team_id: string): Observable<void> {
        let url_ = this.baseUrl + "/seasons/{season_id}/teams/{team_id}";
        if (season_id === undefined || season_id === null)
            throw new Error("The parameter 'season_id' must be defined.");
        url_ = url_.replace("{season_id}", encodeURIComponent("" + season_id)); 
        if (team_id === undefined || team_id === null)
            throw new Error("The parameter 'team_id' must be defined.");
        url_ = url_.replace("{team_id}", encodeURIComponent("" + team_id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTeamFromSeason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTeamFromSeason(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTeamFromSeason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Finds all teams
     * @return list of teams
     */
    getAllTeams(): Observable<Team[]> {
        let url_ = this.baseUrl + "/teams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeams(<any>response_);
                } catch (e) {
                    return <Observable<Team[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Team[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeams(response: HttpResponseBase): Observable<Team[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Team.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Team[]>(<any>null);
    }

    /**
     * Creates a new team
     * @param createTeamBody (optional) 
     * @return Operation successful
     */
    createTeam(createTeamBody?: CreateTeamBody | null | undefined): Observable<Identifier> {
        let url_ = this.baseUrl + "/teams";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTeamBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTeam(<any>response_);
                } catch (e) {
                    return <Observable<Identifier>><any>_observableThrow(e);
                }
            } else
                return <Observable<Identifier>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTeam(response: HttpResponseBase): Observable<Identifier> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Identifier>(<any>null);
    }

    /**
     * Delete a single team by id
     * @param id ID of team
     * @return Deletion successful
     */
    deleteTeam(id: string): Observable<void> {
        let url_ = this.baseUrl + "/teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTeam(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTeam(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Finds a single team by id
     * @param id ID of team
     * @return Single team
     */
    getTeam(id: string): Observable<Team> {
        let url_ = this.baseUrl + "/teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeam(<any>response_);
                } catch (e) {
                    return <Observable<Team>><any>_observableThrow(e);
                }
            } else
                return <Observable<Team>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeam(response: HttpResponseBase): Observable<Team> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Team>(<any>null);
    }

    /**
     * Renames a team
     * @param id ID of team
     * @param renameTeamBody (optional) 
     * @return Operation successful
     */
    renameTeam(id: string, renameTeamBody?: RenameTeamBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/teams/{id}/name";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(renameTeamBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameTeam(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenameTeam(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Updates the contact person of team
     * @param id ID of team
     * @param updateTeamContactBody (optional) 
     * @return Team contact has been modified successfully
     */
    updateTeamContact(id: string, updateTeamContactBody?: Contact_person | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/teams/{id}/contact";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTeamContactBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTeamContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTeamContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTeamContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Finds all tournaments
     * @return List of tournaments
     */
    getAllTournaments(): Observable<Tournament[]> {
        let url_ = this.baseUrl + "/tournaments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTournaments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTournaments(<any>response_);
                } catch (e) {
                    return <Observable<Tournament[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tournament[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTournaments(response: HttpResponseBase): Observable<Tournament[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Tournament.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tournament[]>(<any>null);
    }

    /**
     * Creates a new tournament
     * @param createTournamentBody (optional) 
     * @return Operation successful
     */
    createTournament(createTournamentBody?: CreateTournamentBody | null | undefined): Observable<Identifier> {
        let url_ = this.baseUrl + "/tournaments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTournamentBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTournament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTournament(<any>response_);
                } catch (e) {
                    return <Observable<Identifier>><any>_observableThrow(e);
                }
            } else
                return <Observable<Identifier>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTournament(response: HttpResponseBase): Observable<Identifier> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Identifier>(<any>null);
    }

    /**
     * Find a single tournament by id
     * @param id ID of tournament
     * @return Single tournament
     */
    getTournament(id: string): Observable<Tournament> {
        let url_ = this.baseUrl + "/tournaments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTournament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTournament(<any>response_);
                } catch (e) {
                    return <Observable<Tournament>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tournament>><any>_observableThrow(response_);
        }));
    }

    protected processGetTournament(response: HttpResponseBase): Observable<Tournament> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tournament.fromJS(resultData200) : new Tournament();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tournament>(<any>null);
    }

    /**
     * Delete a single tournament by id
     * @param id ID of tournament
     * @return Operation successful
     */
    deleteTournament(id: string): Observable<void> {
        let url_ = this.baseUrl + "/tournaments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTournament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTournament(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTournament(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Defines a set of team pairings as a tournament round
     * @param id ID of tournament
     * @param round Number identifying the tournament round
     * @param setRoundBody (optional) 
     * @return Operation successful
     */
    setRound(id: string, round: number, setRoundBody?: SetRoundBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tournaments/{id}/rounds/{round}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (round === undefined || round === null)
            throw new Error("The parameter 'round' must be defined.");
        url_ = url_.replace("{round}", encodeURIComponent("" + round)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setRoundBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRound(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRound(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetRound(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Finds all rounds for a tournament
     * @param id ID of tournament
     * @return Array of rounds
     */
    getRoundsInTournament(id: string): Observable<Match_day[]> {
        let url_ = this.baseUrl + "/tournaments/{id}/rounds";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoundsInTournament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoundsInTournament(<any>response_);
                } catch (e) {
                    return <Observable<Match_day[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Match_day[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoundsInTournament(response: HttpResponseBase): Observable<Match_day[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Match_day.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Match_day[]>(<any>null);
    }

    /**
     * Find all users
     * @return Array of users
     */
    getAllUsers(): Observable<void> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create a user
     * @param createUserBody (optional) 
     * @return Operation successful
     */
    createUser(createUserBody?: CreateUserBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve the authenticated user
     * @return The authenticated user as object
     */
    getAuthenticatedUser(): Observable<User> {
        let url_ = this.baseUrl + "/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthenticatedUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthenticatedUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthenticatedUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * Change the authenticated user's password
     * @param changePasswordBody (optional) 
     * @return Operation successful
     */
    changePassword(changePasswordBody?: ChangePasswordBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/users/me/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changePasswordBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Sends a password reset mail for the user with the given email address
     * @param sendPasswordResetMailBody (optional) 
     * @return Operation successful
     */
    sendPasswordResetMail(sendPasswordResetMailBody?: SendPasswordResetMailBody | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/users/me/password/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendPasswordResetMailBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetMail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class Identifier implements IIdentifier {
    id?: string | undefined;

    constructor(data?: IIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Identifier {
        data = typeof data === 'object' ? data : {};
        let result = new Identifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IIdentifier {
    id?: string | undefined;
}

export class Match implements IMatch {
    cancelled_at?: Date | undefined;
    cancellation_reason?: string | undefined;
    guest_score?: number | undefined;
    guest_team_id?: string | undefined;
    home_score?: number | undefined;
    home_team_id?: string | undefined;
    id?: string | undefined;
    kickoff?: Date | undefined;
    match_day_id?: string | undefined;
    pitch_id?: string | undefined;

    constructor(data?: IMatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cancelled_at = data["cancelled_at"] ? new Date(data["cancelled_at"].toString()) : <any>undefined;
            this.cancellation_reason = data["cancellation_reason"];
            this.guest_score = data["guest_score"];
            this.guest_team_id = data["guest_team_id"];
            this.home_score = data["home_score"];
            this.home_team_id = data["home_team_id"];
            this.id = data["id"];
            this.kickoff = data["kickoff"] ? new Date(data["kickoff"].toString()) : <any>undefined;
            this.match_day_id = data["match_day_id"];
            this.pitch_id = data["pitch_id"];
        }
    }

    static fromJS(data: any): Match {
        data = typeof data === 'object' ? data : {};
        let result = new Match();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cancelled_at"] = this.cancelled_at ? this.cancelled_at.toISOString() : <any>undefined;
        data["cancellation_reason"] = this.cancellation_reason;
        data["guest_score"] = this.guest_score;
        data["guest_team_id"] = this.guest_team_id;
        data["home_score"] = this.home_score;
        data["home_team_id"] = this.home_team_id;
        data["id"] = this.id;
        data["kickoff"] = this.kickoff ? this.kickoff.toISOString() : <any>undefined;
        data["match_day_id"] = this.match_day_id;
        data["pitch_id"] = this.pitch_id;
        return data; 
    }
}

export interface IMatch {
    cancelled_at?: Date | undefined;
    cancellation_reason?: string | undefined;
    guest_score?: number | undefined;
    guest_team_id?: string | undefined;
    home_score?: number | undefined;
    home_team_id?: string | undefined;
    id?: string | undefined;
    kickoff?: Date | undefined;
    match_day_id?: string | undefined;
    pitch_id?: string | undefined;
}

export class Pitch implements IPitch {
    id?: string | undefined;
    label?: string | undefined;
    location_latitude?: number | undefined;
    location_longitude?: number | undefined;
    contact?: Contact_person | undefined;

    constructor(data?: IPitch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.label = data["label"];
            this.location_latitude = data["location_latitude"];
            this.location_longitude = data["location_longitude"];
            this.contact = data["contact"] ? Contact_person.fromJS(data["contact"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Pitch {
        data = typeof data === 'object' ? data : {};
        let result = new Pitch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["location_latitude"] = this.location_latitude;
        data["location_longitude"] = this.location_longitude;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPitch {
    id?: string | undefined;
    label?: string | undefined;
    location_latitude?: number | undefined;
    location_longitude?: number | undefined;
    contact?: Contact_person | undefined;
}

export class Ranking implements IRanking {
    positions?: Ranking_position[] | undefined;
    penalties?: Ranking_penalty[] | undefined;
    season_id?: string | undefined;
    updated_at?: Date | undefined;

    constructor(data?: IRanking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["positions"] && data["positions"].constructor === Array) {
                this.positions = [];
                for (let item of data["positions"])
                    this.positions.push(Ranking_position.fromJS(item));
            }
            if (data["penalties"] && data["penalties"].constructor === Array) {
                this.penalties = [];
                for (let item of data["penalties"])
                    this.penalties.push(Ranking_penalty.fromJS(item));
            }
            this.season_id = data["season_id"];
            this.updated_at = data["updated_at"] ? new Date(data["updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Ranking {
        data = typeof data === 'object' ? data : {};
        let result = new Ranking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.positions && this.positions.constructor === Array) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        if (this.penalties && this.penalties.constructor === Array) {
            data["penalties"] = [];
            for (let item of this.penalties)
                data["penalties"].push(item.toJSON());
        }
        data["season_id"] = this.season_id;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRanking {
    positions?: Ranking_position[] | undefined;
    penalties?: Ranking_penalty[] | undefined;
    season_id?: string | undefined;
    updated_at?: Date | undefined;
}

export class Ranking_position implements IRanking_position {
    conceded_goals?: number | undefined;
    draws?: number | undefined;
    losses?: number | undefined;
    matches?: number | undefined;
    number?: number | undefined;
    points?: number | undefined;
    scored_goals?: number | undefined;
    season_id?: string | undefined;
    sort_index?: number | undefined;
    team_id?: string | undefined;
    wins?: number | undefined;

    constructor(data?: IRanking_position) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.conceded_goals = data["conceded_goals"];
            this.draws = data["draws"];
            this.losses = data["losses"];
            this.matches = data["matches"];
            this.number = data["number"];
            this.points = data["points"];
            this.scored_goals = data["scored_goals"];
            this.season_id = data["season_id"];
            this.sort_index = data["sort_index"];
            this.team_id = data["team_id"];
            this.wins = data["wins"];
        }
    }

    static fromJS(data: any): Ranking_position {
        data = typeof data === 'object' ? data : {};
        let result = new Ranking_position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conceded_goals"] = this.conceded_goals;
        data["draws"] = this.draws;
        data["losses"] = this.losses;
        data["matches"] = this.matches;
        data["number"] = this.number;
        data["points"] = this.points;
        data["scored_goals"] = this.scored_goals;
        data["season_id"] = this.season_id;
        data["sort_index"] = this.sort_index;
        data["team_id"] = this.team_id;
        data["wins"] = this.wins;
        return data; 
    }
}

export interface IRanking_position {
    conceded_goals?: number | undefined;
    draws?: number | undefined;
    losses?: number | undefined;
    matches?: number | undefined;
    number?: number | undefined;
    points?: number | undefined;
    scored_goals?: number | undefined;
    season_id?: string | undefined;
    sort_index?: number | undefined;
    team_id?: string | undefined;
    wins?: number | undefined;
}

export class Ranking_penalty implements IRanking_penalty {
    id?: string | undefined;
    season_id?: string | undefined;
    team_id?: string | undefined;
    reason?: string | undefined;
    points?: number | undefined;
    created_at?: Date | undefined;

    constructor(data?: IRanking_penalty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.season_id = data["season_id"];
            this.team_id = data["team_id"];
            this.reason = data["reason"];
            this.points = data["points"];
            this.created_at = data["created_at"] ? new Date(data["created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Ranking_penalty {
        data = typeof data === 'object' ? data : {};
        let result = new Ranking_penalty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["season_id"] = this.season_id;
        data["team_id"] = this.team_id;
        data["reason"] = this.reason;
        data["points"] = this.points;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRanking_penalty {
    id?: string | undefined;
    season_id?: string | undefined;
    team_id?: string | undefined;
    reason?: string | undefined;
    points?: number | undefined;
    created_at?: Date | undefined;
}

export class Season implements ISeason {
    id?: string | undefined;
    name?: string | undefined;
    state?: SeasonState | undefined;
    team_count?: number | undefined;

    constructor(data?: ISeason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.state = data["state"];
            this.team_count = data["team_count"];
        }
    }

    static fromJS(data: any): Season {
        data = typeof data === 'object' ? data : {};
        let result = new Season();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["team_count"] = this.team_count;
        return data; 
    }
}

export interface ISeason {
    id?: string | undefined;
    name?: string | undefined;
    state?: SeasonState | undefined;
    team_count?: number | undefined;
}

export class Tournament implements ITournament {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: ITournament) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Tournament {
        data = typeof data === 'object' ? data : {};
        let result = new Tournament();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITournament {
    id?: string | undefined;
    name?: string | undefined;
}

export class Team implements ITeam {
    created_at?: Date | undefined;
    id?: string | undefined;
    name?: string | undefined;
    contact?: Contact_person | undefined;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"] ? new Date(data["created_at"].toString()) : <any>undefined;
            this.id = data["id"];
            this.name = data["name"];
            this.contact = data["contact"] ? Contact_person.fromJS(data["contact"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITeam {
    created_at?: Date | undefined;
    id?: string | undefined;
    name?: string | undefined;
    contact?: Contact_person | undefined;
}

export class User implements IUser {
    id?: string | undefined;
    email?: string | undefined;
    teams?: string[] | undefined;
    role?: UserRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.email = data["email"];
            if (data["teams"] && data["teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["teams"])
                    this.teams.push(item);
            }
            this.role = data["role"];
            this.first_name = data["first_name"];
            this.last_name = data["last_name"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        if (this.teams && this.teams.constructor === Array) {
            data["teams"] = [];
            for (let item of this.teams)
                data["teams"].push(item);
        }
        data["role"] = this.role;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        return data; 
    }
}

export interface IUser {
    id?: string | undefined;
    email?: string | undefined;
    teams?: string[] | undefined;
    role?: UserRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
}

export class Contact_person implements IContact_person {
    first_name?: string | undefined;
    last_name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContact_person) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first_name = data["first_name"];
            this.last_name = data["last_name"];
            this.phone = data["phone"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): Contact_person {
        data = typeof data === 'object' ? data : {};
        let result = new Contact_person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface IContact_person {
    first_name?: string | undefined;
    last_name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class Match_day implements IMatch_day {
    id?: string | undefined;
    number?: number | undefined;
    start_date?: Date | undefined;
    end_date?: Date | undefined;

    constructor(data?: IMatch_day) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.number = data["number"];
            this.start_date = data["start_date"] ? new Date(data["start_date"].toString()) : <any>undefined;
            this.end_date = data["end_date"] ? new Date(data["end_date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Match_day {
        data = typeof data === 'object' ? data : {};
        let result = new Match_day();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["start_date"] = this.start_date ? formatDate(this.start_date) : <any>undefined;
        data["end_date"] = this.end_date ? formatDate(this.end_date) : <any>undefined;
        return data; 
    }
}

export interface IMatch_day {
    id?: string | undefined;
    number?: number | undefined;
    start_date?: Date | undefined;
    end_date?: Date | undefined;
}

export class Date_period implements IDate_period {
    from?: Date | undefined;
    to?: Date | undefined;

    constructor(data?: IDate_period) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Date_period {
        data = typeof data === 'object' ? data : {};
        let result = new Date_period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? formatDate(this.from) : <any>undefined;
        data["to"] = this.to ? formatDate(this.to) : <any>undefined;
        return data; 
    }
}

export interface IDate_period {
    from?: Date | undefined;
    to?: Date | undefined;
}

export class Event implements IEvent {
    id?: string | undefined;
    occurred_at?: Date | undefined;
    payload?: any | undefined;
    type?: EventType | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.occurred_at = data["occurred_at"] ? new Date(data["occurred_at"].toString()) : <any>undefined;
            this.payload = data["payload"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["occurred_at"] = this.occurred_at ? this.occurred_at.toISOString() : <any>undefined;
        data["payload"] = this.payload;
        data["type"] = this.type;
        return data; 
    }
}

export interface IEvent {
    id?: string | undefined;
    occurred_at?: Date | undefined;
    payload?: any | undefined;
    type?: EventType | undefined;
}

export class CancelMatchBody implements ICancelMatchBody {
    reason: string;

    constructor(data?: ICancelMatchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reason = data["reason"];
        }
    }

    static fromJS(data: any): CancelMatchBody {
        data = typeof data === 'object' ? data : {};
        let result = new CancelMatchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data; 
    }
}

export interface ICancelMatchBody {
    reason: string;
}

export class ScheduleMatchBody implements IScheduleMatchBody {
    kickoff: Date;

    constructor(data?: IScheduleMatchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kickoff = data["kickoff"] ? new Date(data["kickoff"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleMatchBody {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleMatchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kickoff"] = this.kickoff ? this.kickoff.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IScheduleMatchBody {
    kickoff: Date;
}

export class LocateMatchBody implements ILocateMatchBody {
    pitch_id: string;

    constructor(data?: ILocateMatchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pitch_id = data["pitch_id"];
        }
    }

    static fromJS(data: any): LocateMatchBody {
        data = typeof data === 'object' ? data : {};
        let result = new LocateMatchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pitch_id"] = this.pitch_id;
        return data; 
    }
}

export interface ILocateMatchBody {
    pitch_id: string;
}

export class SubmitMatchResultBody implements ISubmitMatchResultBody {
    guest_score: number;
    home_score: number;

    constructor(data?: ISubmitMatchResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.guest_score = data["guest_score"];
            this.home_score = data["home_score"];
        }
    }

    static fromJS(data: any): SubmitMatchResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitMatchResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guest_score"] = this.guest_score;
        data["home_score"] = this.home_score;
        return data; 
    }
}

export interface ISubmitMatchResultBody {
    guest_score: number;
    home_score: number;
}

export class ScheduleMatchDayBody implements IScheduleMatchDayBody {
    date_period: Date_period;

    constructor(data?: IScheduleMatchDayBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_period = data["date_period"] ? Date_period.fromJS(data["date_period"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleMatchDayBody {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleMatchDayBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_period"] = this.date_period ? this.date_period.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IScheduleMatchDayBody {
    date_period: Date_period;
}

export class CreatePitchBody implements ICreatePitchBody {
    label: string;
    location_latitude: number;
    location_longitude: number;

    constructor(data?: ICreatePitchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.location_latitude = data["location_latitude"];
            this.location_longitude = data["location_longitude"];
        }
    }

    static fromJS(data: any): CreatePitchBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePitchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["location_latitude"] = this.location_latitude;
        data["location_longitude"] = this.location_longitude;
        return data; 
    }
}

export interface ICreatePitchBody {
    label: string;
    location_latitude: number;
    location_longitude: number;
}

export class CreateSeasonBody implements ICreateSeasonBody {
    name: string;

    constructor(data?: ICreateSeasonBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateSeasonBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSeasonBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateSeasonBody {
    name: string;
}

export class CreateMatchDaysBody implements ICreateMatchDaysBody {
    dates: Date_period[];

    constructor(data?: ICreateMatchDaysBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dates = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dates"] && data["dates"].constructor === Array) {
                this.dates = [];
                for (let item of data["dates"])
                    this.dates.push(Date_period.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMatchDaysBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchDaysBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dates && this.dates.constructor === Array) {
            data["dates"] = [];
            for (let item of this.dates)
                data["dates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateMatchDaysBody {
    dates: Date_period[];
}

export class CreateRankingPenaltyBody implements ICreateRankingPenaltyBody {
    reason?: string | undefined;
    points?: number | undefined;
    team_id?: string | undefined;

    constructor(data?: ICreateRankingPenaltyBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reason = data["reason"];
            this.points = data["points"];
            this.team_id = data["team_id"];
        }
    }

    static fromJS(data: any): CreateRankingPenaltyBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRankingPenaltyBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["points"] = this.points;
        data["team_id"] = this.team_id;
        return data; 
    }
}

export interface ICreateRankingPenaltyBody {
    reason?: string | undefined;
    points?: number | undefined;
    team_id?: string | undefined;
}

export class CreateTeamBody implements ICreateTeamBody {
    name: string;

    constructor(data?: ICreateTeamBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateTeamBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeamBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateTeamBody {
    name: string;
}

export class RenameTeamBody implements IRenameTeamBody {
    name: string;

    constructor(data?: IRenameTeamBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RenameTeamBody {
        data = typeof data === 'object' ? data : {};
        let result = new RenameTeamBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IRenameTeamBody {
    name: string;
}

export class CreateTournamentBody implements ICreateTournamentBody {
    name: string;

    constructor(data?: ICreateTournamentBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateTournamentBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTournamentBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateTournamentBody {
    name: string;
}

export class SetRoundBody implements ISetRoundBody {
    team_pairs?: Team_pairs[] | undefined;
    date_period?: Date_period | undefined;

    constructor(data?: ISetRoundBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["team_pairs"] && data["team_pairs"].constructor === Array) {
                this.team_pairs = [];
                for (let item of data["team_pairs"])
                    this.team_pairs.push(Team_pairs.fromJS(item));
            }
            this.date_period = data["date_period"] ? Date_period.fromJS(data["date_period"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetRoundBody {
        data = typeof data === 'object' ? data : {};
        let result = new SetRoundBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.team_pairs && this.team_pairs.constructor === Array) {
            data["team_pairs"] = [];
            for (let item of this.team_pairs)
                data["team_pairs"].push(item.toJSON());
        }
        data["date_period"] = this.date_period ? this.date_period.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetRoundBody {
    team_pairs?: Team_pairs[] | undefined;
    date_period?: Date_period | undefined;
}

export class CreateUserBody implements ICreateUserBody {
    email?: string | undefined;
    password?: string | undefined;
    teams?: string[] | undefined;
    role?: CreateUserBodyRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;

    constructor(data?: ICreateUserBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
            if (data["teams"] && data["teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["teams"])
                    this.teams.push(item);
            }
            this.role = data["role"];
            this.first_name = data["first_name"];
            this.last_name = data["last_name"];
        }
    }

    static fromJS(data: any): CreateUserBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        if (this.teams && this.teams.constructor === Array) {
            data["teams"] = [];
            for (let item of this.teams)
                data["teams"].push(item);
        }
        data["role"] = this.role;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        return data; 
    }
}

export interface ICreateUserBody {
    email?: string | undefined;
    password?: string | undefined;
    teams?: string[] | undefined;
    role?: CreateUserBodyRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
}

export class ChangePasswordBody implements IChangePasswordBody {
    new_password: string;

    constructor(data?: IChangePasswordBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.new_password = data["new_password"];
        }
    }

    static fromJS(data: any): ChangePasswordBody {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["new_password"] = this.new_password;
        return data; 
    }
}

export interface IChangePasswordBody {
    new_password: string;
}

export class SendPasswordResetMailBody implements ISendPasswordResetMailBody {
    email: string;
    target_path: string;

    constructor(data?: ISendPasswordResetMailBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.target_path = data["target_path"];
        }
    }

    static fromJS(data: any): SendPasswordResetMailBody {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetMailBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["target_path"] = this.target_path;
        return data; 
    }
}

export interface ISendPasswordResetMailBody {
    email: string;
    target_path: string;
}

export enum SeasonState {
    Preparation = <any>"preparation", 
    Progress = <any>"progress", 
    Ended = <any>"ended", 
}

export enum UserRole {
    Admin = <any>"admin", 
    Team_manager = <any>"team_manager", 
}

export enum EventType {
    MatchLocated = <any>"match:located", 
    MatchResultSubmitted = <any>"match:result:submitted", 
    MatchScheduled = <any>"match:scheduled", 
    MatchCancelled = <any>"match:cancelled", 
    RankingPenaltyAdded = <any>"ranking:penalty:added", 
    RankingPenaltyRemoved = <any>"ranking:penalty:removed", 
    TeamRenamed = <any>"team:renamed", 
}

export class Team_pairs implements ITeam_pairs {
    home_team_id?: string | undefined;
    guest_team_id?: string | undefined;

    constructor(data?: ITeam_pairs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.home_team_id = data["home_team_id"];
            this.guest_team_id = data["guest_team_id"];
        }
    }

    static fromJS(data: any): Team_pairs {
        data = typeof data === 'object' ? data : {};
        let result = new Team_pairs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["home_team_id"] = this.home_team_id;
        data["guest_team_id"] = this.guest_team_id;
        return data; 
    }
}

export interface ITeam_pairs {
    home_team_id?: string | undefined;
    guest_team_id?: string | undefined;
}

export enum CreateUserBodyRole {
    Admin = <any>"admin", 
    Team_manager = <any>"team_manager", 
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}