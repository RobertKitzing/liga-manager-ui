<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>liga-manager-ui documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">liga-manager-ui documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search">
</div>
            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>IRanking_penalty</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/api/liga-manager-api.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#created_at">created_at</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#id">id</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#points">points</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#reason">reason</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#season_id">season_id</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#team_id">team_id</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="created_at"></a>
                                        <span class="name"><b>created_at</b><a href="#created_at"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>created_at:     <code>Date | undefined</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Date | undefined</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="id"></a>
                                        <span class="name"><b>id</b><a href="#id"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>id:     <code>string | undefined</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string | undefined</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="points"></a>
                                        <span class="name"><b>points</b><a href="#points"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>points:     <code>number | undefined</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>number | undefined</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="reason"></a>
                                        <span class="name"><b>reason</b><a href="#reason"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>reason:     <code>string | undefined</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string | undefined</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="season_id"></a>
                                        <span class="name"><b>season_id</b><a href="#season_id"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>season_id:     <code>string | undefined</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string | undefined</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="team_id"></a>
                                        <span class="name"><b>team_id</b><a href="#team_id"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>team_id:     <code>string | undefined</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string | undefined</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { mergeMap as _observableMergeMap, catchError as _observableCatch } from &#x27;rxjs/operators&#x27;;
import { Observable, throwError as _observableThrow, of as _observableOf } from &#x27;rxjs&#x27;;
import { Injectable, Inject, Optional, InjectionToken } from &#x27;@angular/core&#x27;;
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from &#x27;@angular/common/http&#x27;;

export const API_BASE_URL &#x3D; new InjectionToken&lt;string&gt;(&#x27;API_BASE_URL&#x27;);

export interface IClient {
    /**
     * Returns a list of latest events
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param type (optional) 
     * @return Array of events
     */
    getLatestEvents(start_date?: Date | null | undefined, end_date?: Date | null | undefined, type?: string | null | undefined): Observable&lt;Event[]&gt;;
    /**
     * Returns a single event
     * @return An event object
     */
    getEvent(id: string): Observable&lt;Event&gt;;
    /**
     * Find matches by multiple filter criteria
     * @param season_id (optional) 
     * @param tournament_id (optional) 
     * @param team_id (optional) 
     * @param match_day_id (optional) 
     * @return Array of matches
     */
    getMatches(season_id?: string | null | undefined, tournament_id?: string | null | undefined, team_id?: string | null | undefined, match_day_id?: string | null | undefined): Observable&lt;Match[]&gt;;
    /**
     * Find a single match by id
     * @param id match id
     * @return Contains a single match object
     */
    getMatch(id: string): Observable&lt;Match&gt;;
    /**
     * Cancel a match
     * @param id match id
     * @param cancelMatchBody (optional) 
     * @return Operation successful
     */
    cancelMatch(id: string, cancelMatchBody?: CancelMatchBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Schedule a match
     * @param id match id
     * @param scheduleMatchBody (optional) 
     * @return Operation successful
     */
    scheduleMatch(id: string, scheduleMatchBody?: ScheduleMatchBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Locate a match on a pitch
     * @param id match id
     * @param locateMatchBody (optional) 
     * @return Operation successful
     */
    locateMatch(id: string, locateMatchBody?: LocateMatchBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Submit a matches result
     * @param id match id
     * @param submitMatchResultBody (optional) 
     * @return Operation successful
     */
    submitMatchResult(id: string, submitMatchResultBody?: SubmitMatchResultBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Reschedules a matchday
     * @param id matchday id
     * @param scheduleMatchDayBody (optional) 
     * @return Operation successful
     */
    rescheduleMatchDay(id: string, scheduleMatchDayBody?: ScheduleMatchDayBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Find all pitches
     * @return Array of pitches
     */
    getAllPitches(): Observable&lt;Pitch[]&gt;;
    /**
     * Creates a new pitch
     * @param createPitchBody (optional) 
     * @return Operation successful
     */
    createPitch(createPitchBody?: CreatePitchBody | null | undefined): Observable&lt;Identifier&gt;;
    /**
     * Delete a single pitch
     * @param id pitch id
     * @return Deletion successful
     */
    deletePitch(id: string): Observable&lt;void&gt;;
    /**
     * Find a single pitch by id
     * @param id pitch id
     * @return Contains a single pitch object
     */
    getPitch(id: string): Observable&lt;Pitch&gt;;
    /**
     * Updates the contact person of a pitch
     * @param id ID of pitch
     * @param updatePitchContactBody (optional) 
     * @return Pitch contact has been modified successfully
     */
    updatePitchContact(id: string, updatePitchContactBody?: Contact_person | null | undefined): Observable&lt;void&gt;;
    /**
     * Find all seasons
     * @return List of seasons
     */
    getAllSeasons(): Observable&lt;Season[]&gt;;
    /**
     * Create a new season
     * @param createSeasonBody (optional) 
     * @return Operation successful
     */
    createSeason(createSeasonBody?: CreateSeasonBody | null | undefined): Observable&lt;Identifier&gt;;
    /**
     * Delete a single season
     * @param id ID of season
     * @return Deletion successful
     */
    deleteSeason(id: string): Observable&lt;void&gt;;
    /**
     * Finds a single season
     * @param id ID of season
     * @return Contains a single season object
     */
    getSeason(id: string): Observable&lt;Season&gt;;
    /**
     * Find season matchdays
     * @param id ID of season
     * @return Array of matchdays
     */
    getMatchDaysInSeason(id: string): Observable&lt;Match_day[]&gt;;
    /**
     * Creates matchdays &amp; matches for a given season
     * @param id ID of season
     * @param createMatchDaysBody (optional) 
     * @return Operation successful
     */
    createMatchDays(id: string, createMatchDaysBody?: CreateMatchDaysBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Returns the current season ranking
     * @param id ID of season
     * @return Current season ranking
     */
    getRanking(id: string): Observable&lt;Ranking&gt;;
    /**
     * Creates a ranking penalty for a team
     * @param season_id ID of season
     * @param createRankingPenaltyBody (optional) 
     * @return Operation successful
     */
    createRankingPenalty(season_id: string, createRankingPenaltyBody?: CreateRankingPenaltyBody | null | undefined): Observable&lt;Identifier&gt;;
    /**
     * Deletes a ranking penalty
     * @param season_id ID of season
     * @param penalty_id ID of ranking penalty
     * @return Operation successful
     */
    deleteRankingPenalty(season_id: string, penalty_id: string): Observable&lt;void&gt;;
    /**
     * Starts a season
     * @param id ID of season
     * @return Season has been successfully started
     */
    startSeason(id: string): Observable&lt;void&gt;;
    /**
     * Ends a season
     * @param id ID of season
     * @return Operation successful
     */
    endSeason(id: string): Observable&lt;void&gt;;
    /**
     * Find all teams related to a single season
     * @param id ID of season
     * @return Array of teams related to the season
     */
    getTeamsInSeason(id: string): Observable&lt;Team[]&gt;;
    /**
     * Add a team to a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    addTeamToSeason(season_id: string, team_id: string): Observable&lt;void&gt;;
    /**
     * Remove a team from a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    removeTeamFromSeason(season_id: string, team_id: string): Observable&lt;void&gt;;
    /**
     * Finds all teams
     * @return list of teams
     */
    getAllTeams(): Observable&lt;Team[]&gt;;
    /**
     * Creates a new team
     * @param createTeamBody (optional) 
     * @return Operation successful
     */
    createTeam(createTeamBody?: CreateTeamBody | null | undefined): Observable&lt;Identifier&gt;;
    /**
     * Delete a single team by id
     * @param id ID of team
     * @return Deletion successful
     */
    deleteTeam(id: string): Observable&lt;void&gt;;
    /**
     * Finds a single team by id
     * @param id ID of team
     * @return Single team
     */
    getTeam(id: string): Observable&lt;Team&gt;;
    /**
     * Renames a team
     * @param id ID of team
     * @param renameTeamBody (optional) 
     * @return Operation successful
     */
    renameTeam(id: string, renameTeamBody?: RenameTeamBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Updates the contact person of team
     * @param id ID of team
     * @param updateTeamContactBody (optional) 
     * @return Team contact has been modified successfully
     */
    updateTeamContact(id: string, updateTeamContactBody?: Contact_person | null | undefined): Observable&lt;void&gt;;
    /**
     * Finds all tournaments
     * @return List of tournaments
     */
    getAllTournaments(): Observable&lt;Tournament[]&gt;;
    /**
     * Creates a new tournament
     * @param createTournamentBody (optional) 
     * @return Operation successful
     */
    createTournament(createTournamentBody?: CreateTournamentBody | null | undefined): Observable&lt;Identifier&gt;;
    /**
     * Find a single tournament by id
     * @param id ID of tournament
     * @return Single tournament
     */
    getTournament(id: string): Observable&lt;Tournament&gt;;
    /**
     * Delete a single tournament by id
     * @param id ID of tournament
     * @return Operation successful
     */
    deleteTournament(id: string): Observable&lt;void&gt;;
    /**
     * Defines a set of team pairings as a tournament round
     * @param id ID of tournament
     * @param round Number identifying the tournament round
     * @param setRoundBody (optional) 
     * @return Operation successful
     */
    setRound(id: string, round: number, setRoundBody?: SetRoundBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Finds all rounds for a tournament
     * @param id ID of tournament
     * @return Array of rounds
     */
    getRoundsInTournament(id: string): Observable&lt;Match_day[]&gt;;
    /**
     * Find all users
     * @return Array of users
     */
    getAllUsers(): Observable&lt;void&gt;;
    /**
     * Create a user
     * @param createUserBody (optional) 
     * @return Operation successful
     */
    createUser(createUserBody?: CreateUserBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Retrieve the authenticated user
     * @return The authenticated user as object
     */
    getAuthenticatedUser(): Observable&lt;User&gt;;
    /**
     * Change the authenticated user&#x27;s password
     * @param changePasswordBody (optional) 
     * @return Operation successful
     */
    changePassword(changePasswordBody?: ChangePasswordBody | null | undefined): Observable&lt;void&gt;;
    /**
     * Sends a password reset mail for the user with the given email address
     * @param sendPasswordResetMailBody (optional) 
     * @return Operation successful
     */
    sendPasswordResetMail(sendPasswordResetMailBody?: SendPasswordResetMailBody | null | undefined): Observable&lt;void&gt;;
}

@Injectable({
    providedIn: &#x27;root&#x27;
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) &#x3D;&gt; any) | undefined &#x3D; undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http &#x3D; http;
        this.baseUrl &#x3D; baseUrl ? baseUrl : &quot;/api&quot;;
    }

    /**
     * Returns a list of latest events
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param type (optional) 
     * @return Array of events
     */
    getLatestEvents(start_date?: Date | null | undefined, end_date?: Date | null | undefined, type?: string | null | undefined): Observable&lt;Event[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/events?&quot;;
        if (start_date !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;start_date&#x3D;&quot; + encodeURIComponent(start_date ? &quot;&quot; + start_date.toJSON() : &quot;&quot;) + &quot;&amp;&quot;; 
        if (end_date !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;end_date&#x3D;&quot; + encodeURIComponent(end_date ? &quot;&quot; + end_date.toJSON() : &quot;&quot;) + &quot;&amp;&quot;; 
        if (type !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;type&#x3D;&quot; + encodeURIComponent(&quot;&quot; + type) + &quot;&amp;&quot;; 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetLatestEvents(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestEvents(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Event[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Event[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetLatestEvents(response: HttpResponseBase): Observable&lt;Event[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Event.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Event[]&gt;(&lt;any&gt;null);
    }

    /**
     * Returns a single event
     * @return An event object
     */
    getEvent(id: string): Observable&lt;Event&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/events/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetEvent(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvent(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Event&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Event&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetEvent(response: HttpResponseBase): Observable&lt;Event&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Event.fromJS(resultData200) : &lt;any&gt;null;
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Event&gt;(&lt;any&gt;null);
    }

    /**
     * Find matches by multiple filter criteria
     * @param season_id (optional) 
     * @param tournament_id (optional) 
     * @param team_id (optional) 
     * @param match_day_id (optional) 
     * @return Array of matches
     */
    getMatches(season_id?: string | null | undefined, tournament_id?: string | null | undefined, team_id?: string | null | undefined, match_day_id?: string | null | undefined): Observable&lt;Match[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/matches?&quot;;
        if (season_id !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;season_id&#x3D;&quot; + encodeURIComponent(&quot;&quot; + season_id) + &quot;&amp;&quot;; 
        if (tournament_id !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;tournament_id&#x3D;&quot; + encodeURIComponent(&quot;&quot; + tournament_id) + &quot;&amp;&quot;; 
        if (team_id !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;team_id&#x3D;&quot; + encodeURIComponent(&quot;&quot; + team_id) + &quot;&amp;&quot;; 
        if (match_day_id !&#x3D;&#x3D; undefined)
            url_ +&#x3D; &quot;match_day_id&#x3D;&quot; + encodeURIComponent(&quot;&quot; + match_day_id) + &quot;&amp;&quot;; 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetMatches(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatches(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Match[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Match[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetMatches(response: HttpResponseBase): Observable&lt;Match[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Match.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Match[]&gt;(&lt;any&gt;null);
    }

    /**
     * Find a single match by id
     * @param id match id
     * @return Contains a single match object
     */
    getMatch(id: string): Observable&lt;Match&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/matches/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetMatch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Match&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Match&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetMatch(response: HttpResponseBase): Observable&lt;Match&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Match.fromJS(resultData200) : new Match();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Match&gt;(&lt;any&gt;null);
    }

    /**
     * Cancel a match
     * @param id match id
     * @param cancelMatchBody (optional) 
     * @return Operation successful
     */
    cancelMatch(id: string, cancelMatchBody?: CancelMatchBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/matches/{id}/cancellation&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(cancelMatchBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCancelMatch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelMatch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCancelMatch(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Schedule a match
     * @param id match id
     * @param scheduleMatchBody (optional) 
     * @return Operation successful
     */
    scheduleMatch(id: string, scheduleMatchBody?: ScheduleMatchBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/matches/{id}/kickoff&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(scheduleMatchBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processScheduleMatch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleMatch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processScheduleMatch(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Locate a match on a pitch
     * @param id match id
     * @param locateMatchBody (optional) 
     * @return Operation successful
     */
    locateMatch(id: string, locateMatchBody?: LocateMatchBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/matches/{id}/location&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(locateMatchBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processLocateMatch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocateMatch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processLocateMatch(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Submit a matches result
     * @param id match id
     * @param submitMatchResultBody (optional) 
     * @return Operation successful
     */
    submitMatchResult(id: string, submitMatchResultBody?: SubmitMatchResultBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/matches/{id}/result&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(submitMatchResultBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processSubmitMatchResult(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMatchResult(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processSubmitMatchResult(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Reschedules a matchday
     * @param id matchday id
     * @param scheduleMatchDayBody (optional) 
     * @return Operation successful
     */
    rescheduleMatchDay(id: string, scheduleMatchDayBody?: ScheduleMatchDayBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/match_days/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(scheduleMatchDayBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;patch&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processRescheduleMatchDay(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRescheduleMatchDay(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processRescheduleMatchDay(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Find all pitches
     * @return Array of pitches
     */
    getAllPitches(): Observable&lt;Pitch[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/pitches&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetAllPitches(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPitches(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Pitch[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Pitch[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetAllPitches(response: HttpResponseBase): Observable&lt;Pitch[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Pitch.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Pitch[]&gt;(&lt;any&gt;null);
    }

    /**
     * Creates a new pitch
     * @param createPitchBody (optional) 
     * @return Operation successful
     */
    createPitch(createPitchBody?: CreatePitchBody | null | undefined): Observable&lt;Identifier&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/pitches&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createPitchBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreatePitch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePitch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreatePitch(response: HttpResponseBase): Observable&lt;Identifier&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Identifier&gt;(&lt;any&gt;null);
    }

    /**
     * Delete a single pitch
     * @param id pitch id
     * @return Deletion successful
     */
    deletePitch(id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/pitches/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;delete&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processDeletePitch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePitch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processDeletePitch(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Find a single pitch by id
     * @param id pitch id
     * @return Contains a single pitch object
     */
    getPitch(id: string): Observable&lt;Pitch&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/pitches/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetPitch(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPitch(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Pitch&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Pitch&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetPitch(response: HttpResponseBase): Observable&lt;Pitch&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Pitch.fromJS(resultData200) : new Pitch();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Pitch&gt;(&lt;any&gt;null);
    }

    /**
     * Updates the contact person of a pitch
     * @param id ID of pitch
     * @param updatePitchContactBody (optional) 
     * @return Pitch contact has been modified successfully
     */
    updatePitchContact(id: string, updatePitchContactBody?: Contact_person | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/pitches/{id}/contact&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(updatePitchContactBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;put&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processUpdatePitchContact(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePitchContact(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processUpdatePitchContact(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Find all seasons
     * @return List of seasons
     */
    getAllSeasons(): Observable&lt;Season[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetAllSeasons(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSeasons(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Season[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Season[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetAllSeasons(response: HttpResponseBase): Observable&lt;Season[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Season.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Season[]&gt;(&lt;any&gt;null);
    }

    /**
     * Create a new season
     * @param createSeasonBody (optional) 
     * @return Operation successful
     */
    createSeason(createSeasonBody?: CreateSeasonBody | null | undefined): Observable&lt;Identifier&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createSeasonBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreateSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreateSeason(response: HttpResponseBase): Observable&lt;Identifier&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Identifier&gt;(&lt;any&gt;null);
    }

    /**
     * Delete a single season
     * @param id ID of season
     * @return Deletion successful
     */
    deleteSeason(id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;delete&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processDeleteSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processDeleteSeason(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Finds a single season
     * @param id ID of season
     * @return Contains a single season object
     */
    getSeason(id: string): Observable&lt;Season&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Season&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Season&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetSeason(response: HttpResponseBase): Observable&lt;Season&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Season.fromJS(resultData200) : new Season();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Season&gt;(&lt;any&gt;null);
    }

    /**
     * Find season matchdays
     * @param id ID of season
     * @return Array of matchdays
     */
    getMatchDaysInSeason(id: string): Observable&lt;Match_day[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}/match_days&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetMatchDaysInSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchDaysInSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Match_day[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Match_day[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetMatchDaysInSeason(response: HttpResponseBase): Observable&lt;Match_day[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Match_day.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Match_day[]&gt;(&lt;any&gt;null);
    }

    /**
     * Creates matchdays &amp; matches for a given season
     * @param id ID of season
     * @param createMatchDaysBody (optional) 
     * @return Operation successful
     */
    createMatchDays(id: string, createMatchDaysBody?: CreateMatchDaysBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}/match_days&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createMatchDaysBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreateMatchDays(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMatchDays(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreateMatchDays(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Returns the current season ranking
     * @param id ID of season
     * @return Current season ranking
     */
    getRanking(id: string): Observable&lt;Ranking&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}/ranking&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetRanking(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRanking(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Ranking&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Ranking&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetRanking(response: HttpResponseBase): Observable&lt;Ranking&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Ranking.fromJS(resultData200) : new Ranking();
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Ranking&gt;(&lt;any&gt;null);
    }

    /**
     * Creates a ranking penalty for a team
     * @param season_id ID of season
     * @param createRankingPenaltyBody (optional) 
     * @return Operation successful
     */
    createRankingPenalty(season_id: string, createRankingPenaltyBody?: CreateRankingPenaltyBody | null | undefined): Observable&lt;Identifier&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{season_id}/ranking/penalties&quot;;
        if (season_id &#x3D;&#x3D;&#x3D; undefined || season_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;season_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{season_id}&quot;, encodeURIComponent(&quot;&quot; + season_id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createRankingPenaltyBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreateRankingPenalty(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRankingPenalty(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreateRankingPenalty(response: HttpResponseBase): Observable&lt;Identifier&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Identifier&gt;(&lt;any&gt;null);
    }

    /**
     * Deletes a ranking penalty
     * @param season_id ID of season
     * @param penalty_id ID of ranking penalty
     * @return Operation successful
     */
    deleteRankingPenalty(season_id: string, penalty_id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{season_id}/ranking/penalties/{penalty_id}&quot;;
        if (season_id &#x3D;&#x3D;&#x3D; undefined || season_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;season_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{season_id}&quot;, encodeURIComponent(&quot;&quot; + season_id)); 
        if (penalty_id &#x3D;&#x3D;&#x3D; undefined || penalty_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;penalty_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{penalty_id}&quot;, encodeURIComponent(&quot;&quot; + penalty_id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;delete&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processDeleteRankingPenalty(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRankingPenalty(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processDeleteRankingPenalty(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Starts a season
     * @param id ID of season
     * @return Season has been successfully started
     */
    startSeason(id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}/start&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processStartSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processStartSeason(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Ends a season
     * @param id ID of season
     * @return Operation successful
     */
    endSeason(id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}/end&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processEndSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processEndSeason(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Find all teams related to a single season
     * @param id ID of season
     * @return Array of teams related to the season
     */
    getTeamsInSeason(id: string): Observable&lt;Team[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{id}/teams&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetTeamsInSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamsInSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Team[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Team[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetTeamsInSeason(response: HttpResponseBase): Observable&lt;Team[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Team.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Team[]&gt;(&lt;any&gt;null);
    }

    /**
     * Add a team to a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    addTeamToSeason(season_id: string, team_id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{season_id}/teams/{team_id}&quot;;
        if (season_id &#x3D;&#x3D;&#x3D; undefined || season_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;season_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{season_id}&quot;, encodeURIComponent(&quot;&quot; + season_id)); 
        if (team_id &#x3D;&#x3D;&#x3D; undefined || team_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;team_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{team_id}&quot;, encodeURIComponent(&quot;&quot; + team_id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;put&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processAddTeamToSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTeamToSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processAddTeamToSeason(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Remove a team from a season
     * @param season_id ID of season
     * @param team_id ID of team
     * @return Operation successful
     */
    removeTeamFromSeason(season_id: string, team_id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/seasons/{season_id}/teams/{team_id}&quot;;
        if (season_id &#x3D;&#x3D;&#x3D; undefined || season_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;season_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{season_id}&quot;, encodeURIComponent(&quot;&quot; + season_id)); 
        if (team_id &#x3D;&#x3D;&#x3D; undefined || team_id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;team_id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{team_id}&quot;, encodeURIComponent(&quot;&quot; + team_id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;delete&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processRemoveTeamFromSeason(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTeamFromSeason(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processRemoveTeamFromSeason(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Finds all teams
     * @return list of teams
     */
    getAllTeams(): Observable&lt;Team[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/teams&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetAllTeams(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeams(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Team[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Team[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetAllTeams(response: HttpResponseBase): Observable&lt;Team[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Team.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Team[]&gt;(&lt;any&gt;null);
    }

    /**
     * Creates a new team
     * @param createTeamBody (optional) 
     * @return Operation successful
     */
    createTeam(createTeamBody?: CreateTeamBody | null | undefined): Observable&lt;Identifier&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/teams&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createTeamBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreateTeam(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTeam(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreateTeam(response: HttpResponseBase): Observable&lt;Identifier&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Identifier&gt;(&lt;any&gt;null);
    }

    /**
     * Delete a single team by id
     * @param id ID of team
     * @return Deletion successful
     */
    deleteTeam(id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/teams/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;delete&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processDeleteTeam(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTeam(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processDeleteTeam(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Finds a single team by id
     * @param id ID of team
     * @return Single team
     */
    getTeam(id: string): Observable&lt;Team&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/teams/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetTeam(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeam(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Team&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Team&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetTeam(response: HttpResponseBase): Observable&lt;Team&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Team.fromJS(resultData200) : new Team();
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Team&gt;(&lt;any&gt;null);
    }

    /**
     * Renames a team
     * @param id ID of team
     * @param renameTeamBody (optional) 
     * @return Operation successful
     */
    renameTeam(id: string, renameTeamBody?: RenameTeamBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/teams/{id}/name&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(renameTeamBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;put&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processRenameTeam(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameTeam(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processRenameTeam(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Updates the contact person of team
     * @param id ID of team
     * @param updateTeamContactBody (optional) 
     * @return Team contact has been modified successfully
     */
    updateTeamContact(id: string, updateTeamContactBody?: Contact_person | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/teams/{id}/contact&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(updateTeamContactBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;put&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processUpdateTeamContact(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTeamContact(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processUpdateTeamContact(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Finds all tournaments
     * @return List of tournaments
     */
    getAllTournaments(): Observable&lt;Tournament[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/tournaments&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetAllTournaments(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTournaments(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Tournament[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Tournament[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetAllTournaments(response: HttpResponseBase): Observable&lt;Tournament[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Tournament.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Tournament[]&gt;(&lt;any&gt;null);
    }

    /**
     * Creates a new tournament
     * @param createTournamentBody (optional) 
     * @return Operation successful
     */
    createTournament(createTournamentBody?: CreateTournamentBody | null | undefined): Observable&lt;Identifier&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/tournaments&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createTournamentBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreateTournament(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTournament(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Identifier&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreateTournament(response: HttpResponseBase): Observable&lt;Identifier&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Identifier.fromJS(resultData200) : new Identifier();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Identifier&gt;(&lt;any&gt;null);
    }

    /**
     * Find a single tournament by id
     * @param id ID of tournament
     * @return Single tournament
     */
    getTournament(id: string): Observable&lt;Tournament&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/tournaments/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetTournament(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTournament(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Tournament&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Tournament&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetTournament(response: HttpResponseBase): Observable&lt;Tournament&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? Tournament.fromJS(resultData200) : new Tournament();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Tournament&gt;(&lt;any&gt;null);
    }

    /**
     * Delete a single tournament by id
     * @param id ID of tournament
     * @return Operation successful
     */
    deleteTournament(id: string): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/tournaments/{id}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;delete&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processDeleteTournament(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTournament(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processDeleteTournament(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Defines a set of team pairings as a tournament round
     * @param id ID of tournament
     * @param round Number identifying the tournament round
     * @param setRoundBody (optional) 
     * @return Operation successful
     */
    setRound(id: string, round: number, setRoundBody?: SetRoundBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/tournaments/{id}/rounds/{round}&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        if (round &#x3D;&#x3D;&#x3D; undefined || round &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;round&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{round}&quot;, encodeURIComponent(&quot;&quot; + round)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(setRoundBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;put&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processSetRound(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRound(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processSetRound(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Finds all rounds for a tournament
     * @param id ID of tournament
     * @return Array of rounds
     */
    getRoundsInTournament(id: string): Observable&lt;Match_day[]&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/tournaments/{id}/rounds&quot;;
        if (id &#x3D;&#x3D;&#x3D; undefined || id &#x3D;&#x3D;&#x3D; null)
            throw new Error(&quot;The parameter &#x27;id&#x27; must be defined.&quot;);
        url_ &#x3D; url_.replace(&quot;{id}&quot;, encodeURIComponent(&quot;&quot; + id)); 
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetRoundsInTournament(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoundsInTournament(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;Match_day[]&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;Match_day[]&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetRoundsInTournament(response: HttpResponseBase): Observable&lt;Match_day[]&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 &amp;&amp; resultData200.constructor &#x3D;&#x3D;&#x3D; Array) {
                result200 &#x3D; [];
                for (let item of resultData200)
                    result200.push(Match_day.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;Match_day[]&gt;(&lt;any&gt;null);
    }

    /**
     * Find all users
     * @return Array of users
     */
    getAllUsers(): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/users&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Create a user
     * @param createUserBody (optional) 
     * @return Operation successful
     */
    createUser(createUserBody?: CreateUserBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/users&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(createUserBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Retrieve the authenticated user
     * @return The authenticated user as object
     */
    getAuthenticatedUser(): Observable&lt;User&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/users/me&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        let options_ : any &#x3D; {
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Accept&quot;: &quot;application/json&quot;
            })
        };

        return this.http.request(&quot;get&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processGetAuthenticatedUser(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthenticatedUser(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;User&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;User&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processGetAuthenticatedUser(response: HttpResponseBase): Observable&lt;User&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            let result200: any &#x3D; null;
            let resultData200 &#x3D; _responseText &#x3D;&#x3D;&#x3D; &quot;&quot; ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 &#x3D; resultData200 ? User.fromJS(resultData200) : new User();
            return _observableOf(result200);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;User&gt;(&lt;any&gt;null);
    }

    /**
     * Change the authenticated user&#x27;s password
     * @param changePasswordBody (optional) 
     * @return Operation successful
     */
    changePassword(changePasswordBody?: ChangePasswordBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/users/me/password&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(changePasswordBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;put&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }

    /**
     * Sends a password reset mail for the user with the given email address
     * @param sendPasswordResetMailBody (optional) 
     * @return Operation successful
     */
    sendPasswordResetMail(sendPasswordResetMailBody?: SendPasswordResetMailBody | null | undefined): Observable&lt;void&gt; {
        let url_ &#x3D; this.baseUrl + &quot;/users/me/password/reset&quot;;
        url_ &#x3D; url_.replace(/[?&amp;]$/, &quot;&quot;);

        const content_ &#x3D; JSON.stringify(sendPasswordResetMailBody);

        let options_ : any &#x3D; {
            body: content_,
            observe: &quot;response&quot;,
            responseType: &quot;blob&quot;,
            headers: new HttpHeaders({
                &quot;Content-Type&quot;: &quot;application/json&quot;, 
            })
        };

        return this.http.request(&quot;post&quot;, url_, options_).pipe(_observableMergeMap((response_ : any) &#x3D;&gt; {
            return this.processSendPasswordResetMail(response_);
        })).pipe(_observableCatch((response_: any) &#x3D;&gt; {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetMail(&lt;any&gt;response_);
                } catch (e) {
                    return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(e);
                }
            } else
                return &lt;Observable&lt;void&gt;&gt;&lt;any&gt;_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetMail(response: HttpResponseBase): Observable&lt;void&gt; {
        const status &#x3D; response.status;
        const responseBlob &#x3D; 
            response instanceof HttpResponse ? response.body : 
            (&lt;any&gt;response).error instanceof Blob ? (&lt;any&gt;response).error : undefined;

        let _headers: any &#x3D; {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] &#x3D; response.headers.get(key); }};
        if (status &#x3D;&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return _observableOf&lt;void&gt;(&lt;any&gt;null);
            }));
        } else if (status &#x3D;&#x3D;&#x3D; 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;A server error occurred.&quot;, status, _responseText, _headers);
            }));
        } else if (status !&#x3D;&#x3D; 200 &amp;&amp; status !&#x3D;&#x3D; 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText &#x3D;&gt; {
            return throwException(&quot;An unexpected server error occurred.&quot;, status, _responseText, _headers);
            }));
        }
        return _observableOf&lt;void&gt;(&lt;any&gt;null);
    }
}

export class Identifier implements IIdentifier {
    id?: string | undefined;

    constructor(data?: IIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
        }
    }

    static fromJS(data: any): Identifier {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Identifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        return data; 
    }
}

export interface IIdentifier {
    id?: string | undefined;
}

export class Match implements IMatch {
    cancelled_at?: Date | undefined;
    cancellation_reason?: string | undefined;
    guest_score?: number | undefined;
    guest_team_id?: string | undefined;
    home_score?: number | undefined;
    home_team_id?: string | undefined;
    id?: string | undefined;
    kickoff?: Date | undefined;
    match_day_id?: string | undefined;
    pitch_id?: string | undefined;

    constructor(data?: IMatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cancelled_at &#x3D; data[&quot;cancelled_at&quot;] ? new Date(data[&quot;cancelled_at&quot;].toString()) : &lt;any&gt;undefined;
            this.cancellation_reason &#x3D; data[&quot;cancellation_reason&quot;];
            this.guest_score &#x3D; data[&quot;guest_score&quot;];
            this.guest_team_id &#x3D; data[&quot;guest_team_id&quot;];
            this.home_score &#x3D; data[&quot;home_score&quot;];
            this.home_team_id &#x3D; data[&quot;home_team_id&quot;];
            this.id &#x3D; data[&quot;id&quot;];
            this.kickoff &#x3D; data[&quot;kickoff&quot;] ? new Date(data[&quot;kickoff&quot;].toString()) : &lt;any&gt;undefined;
            this.match_day_id &#x3D; data[&quot;match_day_id&quot;];
            this.pitch_id &#x3D; data[&quot;pitch_id&quot;];
        }
    }

    static fromJS(data: any): Match {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Match();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;cancelled_at&quot;] &#x3D; this.cancelled_at ? this.cancelled_at.toISOString() : &lt;any&gt;undefined;
        data[&quot;cancellation_reason&quot;] &#x3D; this.cancellation_reason;
        data[&quot;guest_score&quot;] &#x3D; this.guest_score;
        data[&quot;guest_team_id&quot;] &#x3D; this.guest_team_id;
        data[&quot;home_score&quot;] &#x3D; this.home_score;
        data[&quot;home_team_id&quot;] &#x3D; this.home_team_id;
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;kickoff&quot;] &#x3D; this.kickoff ? this.kickoff.toISOString() : &lt;any&gt;undefined;
        data[&quot;match_day_id&quot;] &#x3D; this.match_day_id;
        data[&quot;pitch_id&quot;] &#x3D; this.pitch_id;
        return data; 
    }
}

export interface IMatch {
    cancelled_at?: Date | undefined;
    cancellation_reason?: string | undefined;
    guest_score?: number | undefined;
    guest_team_id?: string | undefined;
    home_score?: number | undefined;
    home_team_id?: string | undefined;
    id?: string | undefined;
    kickoff?: Date | undefined;
    match_day_id?: string | undefined;
    pitch_id?: string | undefined;
}

export class Pitch implements IPitch {
    id?: string | undefined;
    label?: string | undefined;
    location_latitude?: number | undefined;
    location_longitude?: number | undefined;
    contact?: Contact_person | undefined;

    constructor(data?: IPitch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.label &#x3D; data[&quot;label&quot;];
            this.location_latitude &#x3D; data[&quot;location_latitude&quot;];
            this.location_longitude &#x3D; data[&quot;location_longitude&quot;];
            this.contact &#x3D; data[&quot;contact&quot;] ? Contact_person.fromJS(data[&quot;contact&quot;]) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): Pitch {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Pitch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;label&quot;] &#x3D; this.label;
        data[&quot;location_latitude&quot;] &#x3D; this.location_latitude;
        data[&quot;location_longitude&quot;] &#x3D; this.location_longitude;
        data[&quot;contact&quot;] &#x3D; this.contact ? this.contact.toJSON() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IPitch {
    id?: string | undefined;
    label?: string | undefined;
    location_latitude?: number | undefined;
    location_longitude?: number | undefined;
    contact?: Contact_person | undefined;
}

export class Ranking implements IRanking {
    positions?: Ranking_position[] | undefined;
    penalties?: Ranking_penalty[] | undefined;
    season_id?: string | undefined;
    updated_at?: Date | undefined;

    constructor(data?: IRanking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data[&quot;positions&quot;] &amp;&amp; data[&quot;positions&quot;].constructor &#x3D;&#x3D;&#x3D; Array) {
                this.positions &#x3D; [];
                for (let item of data[&quot;positions&quot;])
                    this.positions.push(Ranking_position.fromJS(item));
            }
            if (data[&quot;penalties&quot;] &amp;&amp; data[&quot;penalties&quot;].constructor &#x3D;&#x3D;&#x3D; Array) {
                this.penalties &#x3D; [];
                for (let item of data[&quot;penalties&quot;])
                    this.penalties.push(Ranking_penalty.fromJS(item));
            }
            this.season_id &#x3D; data[&quot;season_id&quot;];
            this.updated_at &#x3D; data[&quot;updated_at&quot;] ? new Date(data[&quot;updated_at&quot;].toString()) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): Ranking {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Ranking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        if (this.positions &amp;&amp; this.positions.constructor &#x3D;&#x3D;&#x3D; Array) {
            data[&quot;positions&quot;] &#x3D; [];
            for (let item of this.positions)
                data[&quot;positions&quot;].push(item.toJSON());
        }
        if (this.penalties &amp;&amp; this.penalties.constructor &#x3D;&#x3D;&#x3D; Array) {
            data[&quot;penalties&quot;] &#x3D; [];
            for (let item of this.penalties)
                data[&quot;penalties&quot;].push(item.toJSON());
        }
        data[&quot;season_id&quot;] &#x3D; this.season_id;
        data[&quot;updated_at&quot;] &#x3D; this.updated_at ? this.updated_at.toISOString() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IRanking {
    positions?: Ranking_position[] | undefined;
    penalties?: Ranking_penalty[] | undefined;
    season_id?: string | undefined;
    updated_at?: Date | undefined;
}

export class Ranking_position implements IRanking_position {
    conceded_goals?: number | undefined;
    draws?: number | undefined;
    losses?: number | undefined;
    matches?: number | undefined;
    number?: number | undefined;
    points?: number | undefined;
    scored_goals?: number | undefined;
    season_id?: string | undefined;
    sort_index?: number | undefined;
    team_id?: string | undefined;
    wins?: number | undefined;

    constructor(data?: IRanking_position) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.conceded_goals &#x3D; data[&quot;conceded_goals&quot;];
            this.draws &#x3D; data[&quot;draws&quot;];
            this.losses &#x3D; data[&quot;losses&quot;];
            this.matches &#x3D; data[&quot;matches&quot;];
            this.number &#x3D; data[&quot;number&quot;];
            this.points &#x3D; data[&quot;points&quot;];
            this.scored_goals &#x3D; data[&quot;scored_goals&quot;];
            this.season_id &#x3D; data[&quot;season_id&quot;];
            this.sort_index &#x3D; data[&quot;sort_index&quot;];
            this.team_id &#x3D; data[&quot;team_id&quot;];
            this.wins &#x3D; data[&quot;wins&quot;];
        }
    }

    static fromJS(data: any): Ranking_position {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Ranking_position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;conceded_goals&quot;] &#x3D; this.conceded_goals;
        data[&quot;draws&quot;] &#x3D; this.draws;
        data[&quot;losses&quot;] &#x3D; this.losses;
        data[&quot;matches&quot;] &#x3D; this.matches;
        data[&quot;number&quot;] &#x3D; this.number;
        data[&quot;points&quot;] &#x3D; this.points;
        data[&quot;scored_goals&quot;] &#x3D; this.scored_goals;
        data[&quot;season_id&quot;] &#x3D; this.season_id;
        data[&quot;sort_index&quot;] &#x3D; this.sort_index;
        data[&quot;team_id&quot;] &#x3D; this.team_id;
        data[&quot;wins&quot;] &#x3D; this.wins;
        return data; 
    }
}

export interface IRanking_position {
    conceded_goals?: number | undefined;
    draws?: number | undefined;
    losses?: number | undefined;
    matches?: number | undefined;
    number?: number | undefined;
    points?: number | undefined;
    scored_goals?: number | undefined;
    season_id?: string | undefined;
    sort_index?: number | undefined;
    team_id?: string | undefined;
    wins?: number | undefined;
}

export class Ranking_penalty implements IRanking_penalty {
    id?: string | undefined;
    season_id?: string | undefined;
    team_id?: string | undefined;
    reason?: string | undefined;
    points?: number | undefined;
    created_at?: Date | undefined;

    constructor(data?: IRanking_penalty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.season_id &#x3D; data[&quot;season_id&quot;];
            this.team_id &#x3D; data[&quot;team_id&quot;];
            this.reason &#x3D; data[&quot;reason&quot;];
            this.points &#x3D; data[&quot;points&quot;];
            this.created_at &#x3D; data[&quot;created_at&quot;] ? new Date(data[&quot;created_at&quot;].toString()) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): Ranking_penalty {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Ranking_penalty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;season_id&quot;] &#x3D; this.season_id;
        data[&quot;team_id&quot;] &#x3D; this.team_id;
        data[&quot;reason&quot;] &#x3D; this.reason;
        data[&quot;points&quot;] &#x3D; this.points;
        data[&quot;created_at&quot;] &#x3D; this.created_at ? this.created_at.toISOString() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IRanking_penalty {
    id?: string | undefined;
    season_id?: string | undefined;
    team_id?: string | undefined;
    reason?: string | undefined;
    points?: number | undefined;
    created_at?: Date | undefined;
}

export class Season implements ISeason {
    id?: string | undefined;
    name?: string | undefined;
    state?: SeasonState | undefined;
    team_count?: number | undefined;

    constructor(data?: ISeason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.name &#x3D; data[&quot;name&quot;];
            this.state &#x3D; data[&quot;state&quot;];
            this.team_count &#x3D; data[&quot;team_count&quot;];
        }
    }

    static fromJS(data: any): Season {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Season();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;name&quot;] &#x3D; this.name;
        data[&quot;state&quot;] &#x3D; this.state;
        data[&quot;team_count&quot;] &#x3D; this.team_count;
        return data; 
    }
}

export interface ISeason {
    id?: string | undefined;
    name?: string | undefined;
    state?: SeasonState | undefined;
    team_count?: number | undefined;
}

export class Tournament implements ITournament {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: ITournament) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.name &#x3D; data[&quot;name&quot;];
        }
    }

    static fromJS(data: any): Tournament {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Tournament();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;name&quot;] &#x3D; this.name;
        return data; 
    }
}

export interface ITournament {
    id?: string | undefined;
    name?: string | undefined;
}

export class Team implements ITeam {
    created_at?: Date | undefined;
    id?: string | undefined;
    name?: string | undefined;
    contact?: Contact_person | undefined;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at &#x3D; data[&quot;created_at&quot;] ? new Date(data[&quot;created_at&quot;].toString()) : &lt;any&gt;undefined;
            this.id &#x3D; data[&quot;id&quot;];
            this.name &#x3D; data[&quot;name&quot;];
            this.contact &#x3D; data[&quot;contact&quot;] ? Contact_person.fromJS(data[&quot;contact&quot;]) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): Team {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;created_at&quot;] &#x3D; this.created_at ? this.created_at.toISOString() : &lt;any&gt;undefined;
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;name&quot;] &#x3D; this.name;
        data[&quot;contact&quot;] &#x3D; this.contact ? this.contact.toJSON() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface ITeam {
    created_at?: Date | undefined;
    id?: string | undefined;
    name?: string | undefined;
    contact?: Contact_person | undefined;
}

export class User implements IUser {
    id?: string | undefined;
    email?: string | undefined;
    teams?: string[] | undefined;
    role?: UserRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.email &#x3D; data[&quot;email&quot;];
            if (data[&quot;teams&quot;] &amp;&amp; data[&quot;teams&quot;].constructor &#x3D;&#x3D;&#x3D; Array) {
                this.teams &#x3D; [];
                for (let item of data[&quot;teams&quot;])
                    this.teams.push(item);
            }
            this.role &#x3D; data[&quot;role&quot;];
            this.first_name &#x3D; data[&quot;first_name&quot;];
            this.last_name &#x3D; data[&quot;last_name&quot;];
        }
    }

    static fromJS(data: any): User {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;email&quot;] &#x3D; this.email;
        if (this.teams &amp;&amp; this.teams.constructor &#x3D;&#x3D;&#x3D; Array) {
            data[&quot;teams&quot;] &#x3D; [];
            for (let item of this.teams)
                data[&quot;teams&quot;].push(item);
        }
        data[&quot;role&quot;] &#x3D; this.role;
        data[&quot;first_name&quot;] &#x3D; this.first_name;
        data[&quot;last_name&quot;] &#x3D; this.last_name;
        return data; 
    }
}

export interface IUser {
    id?: string | undefined;
    email?: string | undefined;
    teams?: string[] | undefined;
    role?: UserRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
}

export class Contact_person implements IContact_person {
    first_name?: string | undefined;
    last_name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContact_person) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first_name &#x3D; data[&quot;first_name&quot;];
            this.last_name &#x3D; data[&quot;last_name&quot;];
            this.phone &#x3D; data[&quot;phone&quot;];
            this.email &#x3D; data[&quot;email&quot;];
        }
    }

    static fromJS(data: any): Contact_person {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Contact_person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;first_name&quot;] &#x3D; this.first_name;
        data[&quot;last_name&quot;] &#x3D; this.last_name;
        data[&quot;phone&quot;] &#x3D; this.phone;
        data[&quot;email&quot;] &#x3D; this.email;
        return data; 
    }
}

export interface IContact_person {
    first_name?: string | undefined;
    last_name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class Match_day implements IMatch_day {
    id?: string | undefined;
    number?: number | undefined;
    start_date?: Date | undefined;
    end_date?: Date | undefined;

    constructor(data?: IMatch_day) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.number &#x3D; data[&quot;number&quot;];
            this.start_date &#x3D; data[&quot;start_date&quot;] ? new Date(data[&quot;start_date&quot;].toString()) : &lt;any&gt;undefined;
            this.end_date &#x3D; data[&quot;end_date&quot;] ? new Date(data[&quot;end_date&quot;].toString()) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): Match_day {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Match_day();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;number&quot;] &#x3D; this.number;
        data[&quot;start_date&quot;] &#x3D; this.start_date ? formatDate(this.start_date) : &lt;any&gt;undefined;
        data[&quot;end_date&quot;] &#x3D; this.end_date ? formatDate(this.end_date) : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IMatch_day {
    id?: string | undefined;
    number?: number | undefined;
    start_date?: Date | undefined;
    end_date?: Date | undefined;
}

export class Date_period implements IDate_period {
    from?: Date | undefined;
    to?: Date | undefined;

    constructor(data?: IDate_period) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from &#x3D; data[&quot;from&quot;] ? new Date(data[&quot;from&quot;].toString()) : &lt;any&gt;undefined;
            this.to &#x3D; data[&quot;to&quot;] ? new Date(data[&quot;to&quot;].toString()) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): Date_period {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Date_period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;from&quot;] &#x3D; this.from ? formatDate(this.from) : &lt;any&gt;undefined;
        data[&quot;to&quot;] &#x3D; this.to ? formatDate(this.to) : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IDate_period {
    from?: Date | undefined;
    to?: Date | undefined;
}

export class Event implements IEvent {
    id?: string | undefined;
    occurred_at?: Date | undefined;
    payload?: any | undefined;
    type?: EventType | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id &#x3D; data[&quot;id&quot;];
            this.occurred_at &#x3D; data[&quot;occurred_at&quot;] ? new Date(data[&quot;occurred_at&quot;].toString()) : &lt;any&gt;undefined;
            this.payload &#x3D; data[&quot;payload&quot;];
            this.type &#x3D; data[&quot;type&quot;];
        }
    }

    static fromJS(data: any): Event {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;id&quot;] &#x3D; this.id;
        data[&quot;occurred_at&quot;] &#x3D; this.occurred_at ? this.occurred_at.toISOString() : &lt;any&gt;undefined;
        data[&quot;payload&quot;] &#x3D; this.payload;
        data[&quot;type&quot;] &#x3D; this.type;
        return data; 
    }
}

export interface IEvent {
    id?: string | undefined;
    occurred_at?: Date | undefined;
    payload?: any | undefined;
    type?: EventType | undefined;
}

export class CancelMatchBody implements ICancelMatchBody {
    reason: string;

    constructor(data?: ICancelMatchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reason &#x3D; data[&quot;reason&quot;];
        }
    }

    static fromJS(data: any): CancelMatchBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CancelMatchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;reason&quot;] &#x3D; this.reason;
        return data; 
    }
}

export interface ICancelMatchBody {
    reason: string;
}

export class ScheduleMatchBody implements IScheduleMatchBody {
    kickoff: Date;

    constructor(data?: IScheduleMatchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kickoff &#x3D; data[&quot;kickoff&quot;] ? new Date(data[&quot;kickoff&quot;].toString()) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): ScheduleMatchBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new ScheduleMatchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;kickoff&quot;] &#x3D; this.kickoff ? this.kickoff.toISOString() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IScheduleMatchBody {
    kickoff: Date;
}

export class LocateMatchBody implements ILocateMatchBody {
    pitch_id: string;

    constructor(data?: ILocateMatchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pitch_id &#x3D; data[&quot;pitch_id&quot;];
        }
    }

    static fromJS(data: any): LocateMatchBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new LocateMatchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;pitch_id&quot;] &#x3D; this.pitch_id;
        return data; 
    }
}

export interface ILocateMatchBody {
    pitch_id: string;
}

export class SubmitMatchResultBody implements ISubmitMatchResultBody {
    guest_score: number;
    home_score: number;

    constructor(data?: ISubmitMatchResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.guest_score &#x3D; data[&quot;guest_score&quot;];
            this.home_score &#x3D; data[&quot;home_score&quot;];
        }
    }

    static fromJS(data: any): SubmitMatchResultBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new SubmitMatchResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;guest_score&quot;] &#x3D; this.guest_score;
        data[&quot;home_score&quot;] &#x3D; this.home_score;
        return data; 
    }
}

export interface ISubmitMatchResultBody {
    guest_score: number;
    home_score: number;
}

export class ScheduleMatchDayBody implements IScheduleMatchDayBody {
    date_period: Date_period;

    constructor(data?: IScheduleMatchDayBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_period &#x3D; data[&quot;date_period&quot;] ? Date_period.fromJS(data[&quot;date_period&quot;]) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): ScheduleMatchDayBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new ScheduleMatchDayBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;date_period&quot;] &#x3D; this.date_period ? this.date_period.toJSON() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface IScheduleMatchDayBody {
    date_period: Date_period;
}

export class CreatePitchBody implements ICreatePitchBody {
    label: string;
    location_latitude: number;
    location_longitude: number;

    constructor(data?: ICreatePitchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label &#x3D; data[&quot;label&quot;];
            this.location_latitude &#x3D; data[&quot;location_latitude&quot;];
            this.location_longitude &#x3D; data[&quot;location_longitude&quot;];
        }
    }

    static fromJS(data: any): CreatePitchBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreatePitchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;label&quot;] &#x3D; this.label;
        data[&quot;location_latitude&quot;] &#x3D; this.location_latitude;
        data[&quot;location_longitude&quot;] &#x3D; this.location_longitude;
        return data; 
    }
}

export interface ICreatePitchBody {
    label: string;
    location_latitude: number;
    location_longitude: number;
}

export class CreateSeasonBody implements ICreateSeasonBody {
    name: string;

    constructor(data?: ICreateSeasonBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name &#x3D; data[&quot;name&quot;];
        }
    }

    static fromJS(data: any): CreateSeasonBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreateSeasonBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;name&quot;] &#x3D; this.name;
        return data; 
    }
}

export interface ICreateSeasonBody {
    name: string;
}

export class CreateMatchDaysBody implements ICreateMatchDaysBody {
    dates: Date_period[];

    constructor(data?: ICreateMatchDaysBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
        if (!data) {
            this.dates &#x3D; [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data[&quot;dates&quot;] &amp;&amp; data[&quot;dates&quot;].constructor &#x3D;&#x3D;&#x3D; Array) {
                this.dates &#x3D; [];
                for (let item of data[&quot;dates&quot;])
                    this.dates.push(Date_period.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMatchDaysBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreateMatchDaysBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        if (this.dates &amp;&amp; this.dates.constructor &#x3D;&#x3D;&#x3D; Array) {
            data[&quot;dates&quot;] &#x3D; [];
            for (let item of this.dates)
                data[&quot;dates&quot;].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateMatchDaysBody {
    dates: Date_period[];
}

export class CreateRankingPenaltyBody implements ICreateRankingPenaltyBody {
    reason?: string | undefined;
    points?: number | undefined;
    team_id?: string | undefined;

    constructor(data?: ICreateRankingPenaltyBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reason &#x3D; data[&quot;reason&quot;];
            this.points &#x3D; data[&quot;points&quot;];
            this.team_id &#x3D; data[&quot;team_id&quot;];
        }
    }

    static fromJS(data: any): CreateRankingPenaltyBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreateRankingPenaltyBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;reason&quot;] &#x3D; this.reason;
        data[&quot;points&quot;] &#x3D; this.points;
        data[&quot;team_id&quot;] &#x3D; this.team_id;
        return data; 
    }
}

export interface ICreateRankingPenaltyBody {
    reason?: string | undefined;
    points?: number | undefined;
    team_id?: string | undefined;
}

export class CreateTeamBody implements ICreateTeamBody {
    name: string;

    constructor(data?: ICreateTeamBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name &#x3D; data[&quot;name&quot;];
        }
    }

    static fromJS(data: any): CreateTeamBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreateTeamBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;name&quot;] &#x3D; this.name;
        return data; 
    }
}

export interface ICreateTeamBody {
    name: string;
}

export class RenameTeamBody implements IRenameTeamBody {
    name: string;

    constructor(data?: IRenameTeamBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name &#x3D; data[&quot;name&quot;];
        }
    }

    static fromJS(data: any): RenameTeamBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new RenameTeamBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;name&quot;] &#x3D; this.name;
        return data; 
    }
}

export interface IRenameTeamBody {
    name: string;
}

export class CreateTournamentBody implements ICreateTournamentBody {
    name: string;

    constructor(data?: ICreateTournamentBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name &#x3D; data[&quot;name&quot;];
        }
    }

    static fromJS(data: any): CreateTournamentBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreateTournamentBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;name&quot;] &#x3D; this.name;
        return data; 
    }
}

export interface ICreateTournamentBody {
    name: string;
}

export class SetRoundBody implements ISetRoundBody {
    team_pairs?: Team_pairs[] | undefined;
    date_period?: Date_period | undefined;

    constructor(data?: ISetRoundBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data[&quot;team_pairs&quot;] &amp;&amp; data[&quot;team_pairs&quot;].constructor &#x3D;&#x3D;&#x3D; Array) {
                this.team_pairs &#x3D; [];
                for (let item of data[&quot;team_pairs&quot;])
                    this.team_pairs.push(Team_pairs.fromJS(item));
            }
            this.date_period &#x3D; data[&quot;date_period&quot;] ? Date_period.fromJS(data[&quot;date_period&quot;]) : &lt;any&gt;undefined;
        }
    }

    static fromJS(data: any): SetRoundBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new SetRoundBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        if (this.team_pairs &amp;&amp; this.team_pairs.constructor &#x3D;&#x3D;&#x3D; Array) {
            data[&quot;team_pairs&quot;] &#x3D; [];
            for (let item of this.team_pairs)
                data[&quot;team_pairs&quot;].push(item.toJSON());
        }
        data[&quot;date_period&quot;] &#x3D; this.date_period ? this.date_period.toJSON() : &lt;any&gt;undefined;
        return data; 
    }
}

export interface ISetRoundBody {
    team_pairs?: Team_pairs[] | undefined;
    date_period?: Date_period | undefined;
}

export class CreateUserBody implements ICreateUserBody {
    email?: string | undefined;
    password?: string | undefined;
    teams?: string[] | undefined;
    role?: CreateUserBodyRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;

    constructor(data?: ICreateUserBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email &#x3D; data[&quot;email&quot;];
            this.password &#x3D; data[&quot;password&quot;];
            if (data[&quot;teams&quot;] &amp;&amp; data[&quot;teams&quot;].constructor &#x3D;&#x3D;&#x3D; Array) {
                this.teams &#x3D; [];
                for (let item of data[&quot;teams&quot;])
                    this.teams.push(item);
            }
            this.role &#x3D; data[&quot;role&quot;];
            this.first_name &#x3D; data[&quot;first_name&quot;];
            this.last_name &#x3D; data[&quot;last_name&quot;];
        }
    }

    static fromJS(data: any): CreateUserBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new CreateUserBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;email&quot;] &#x3D; this.email;
        data[&quot;password&quot;] &#x3D; this.password;
        if (this.teams &amp;&amp; this.teams.constructor &#x3D;&#x3D;&#x3D; Array) {
            data[&quot;teams&quot;] &#x3D; [];
            for (let item of this.teams)
                data[&quot;teams&quot;].push(item);
        }
        data[&quot;role&quot;] &#x3D; this.role;
        data[&quot;first_name&quot;] &#x3D; this.first_name;
        data[&quot;last_name&quot;] &#x3D; this.last_name;
        return data; 
    }
}

export interface ICreateUserBody {
    email?: string | undefined;
    password?: string | undefined;
    teams?: string[] | undefined;
    role?: CreateUserBodyRole | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
}

export class ChangePasswordBody implements IChangePasswordBody {
    new_password: string;

    constructor(data?: IChangePasswordBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.new_password &#x3D; data[&quot;new_password&quot;];
        }
    }

    static fromJS(data: any): ChangePasswordBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new ChangePasswordBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;new_password&quot;] &#x3D; this.new_password;
        return data; 
    }
}

export interface IChangePasswordBody {
    new_password: string;
}

export class SendPasswordResetMailBody implements ISendPasswordResetMailBody {
    email: string;
    target_path: string;

    constructor(data?: ISendPasswordResetMailBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email &#x3D; data[&quot;email&quot;];
            this.target_path &#x3D; data[&quot;target_path&quot;];
        }
    }

    static fromJS(data: any): SendPasswordResetMailBody {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new SendPasswordResetMailBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;email&quot;] &#x3D; this.email;
        data[&quot;target_path&quot;] &#x3D; this.target_path;
        return data; 
    }
}

export interface ISendPasswordResetMailBody {
    email: string;
    target_path: string;
}

export enum SeasonState {
    Preparation &#x3D; &lt;any&gt;&quot;preparation&quot;, 
    Progress &#x3D; &lt;any&gt;&quot;progress&quot;, 
    Ended &#x3D; &lt;any&gt;&quot;ended&quot;, 
}

export enum UserRole {
    Admin &#x3D; &lt;any&gt;&quot;admin&quot;, 
    Team_manager &#x3D; &lt;any&gt;&quot;team_manager&quot;, 
}

export enum EventType {
    MatchLocated &#x3D; &lt;any&gt;&quot;match:located&quot;, 
    MatchResultSubmitted &#x3D; &lt;any&gt;&quot;match:result:submitted&quot;, 
    MatchScheduled &#x3D; &lt;any&gt;&quot;match:scheduled&quot;, 
    MatchCancelled &#x3D; &lt;any&gt;&quot;match:cancelled&quot;, 
    RankingPenaltyAdded &#x3D; &lt;any&gt;&quot;ranking:penalty:added&quot;, 
    RankingPenaltyRemoved &#x3D; &lt;any&gt;&quot;ranking:penalty:removed&quot;, 
    TeamRenamed &#x3D; &lt;any&gt;&quot;team:renamed&quot;, 
}

export class Team_pairs implements ITeam_pairs {
    home_team_id?: string | undefined;
    guest_team_id?: string | undefined;

    constructor(data?: ITeam_pairs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (&lt;any&gt;this)[property] &#x3D; (&lt;any&gt;data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.home_team_id &#x3D; data[&quot;home_team_id&quot;];
            this.guest_team_id &#x3D; data[&quot;guest_team_id&quot;];
        }
    }

    static fromJS(data: any): Team_pairs {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        let result &#x3D; new Team_pairs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : {};
        data[&quot;home_team_id&quot;] &#x3D; this.home_team_id;
        data[&quot;guest_team_id&quot;] &#x3D; this.guest_team_id;
        return data; 
    }
}

export interface ITeam_pairs {
    home_team_id?: string | undefined;
    guest_team_id?: string | undefined;
}

export enum CreateUserBodyRole {
    Admin &#x3D; &lt;any&gt;&quot;admin&quot;, 
    Team_manager &#x3D; &lt;any&gt;&quot;team_manager&quot;, 
}

function formatDate(d: Date) {
    return d.getFullYear() + &#x27;-&#x27; + 
        (d.getMonth() &lt; 9 ? (&#x27;0&#x27; + (d.getMonth()+1)) : (d.getMonth()+1)) + &#x27;-&#x27; +
        (d.getDate() &lt; 10 ? (&#x27;0&#x27; + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message &#x3D; message;
        this.status &#x3D; status;
        this.response &#x3D; response;
        this.headers &#x3D; headers;
        this.result &#x3D; result;
    }

    protected isSwaggerException &#x3D; true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException &#x3D;&#x3D;&#x3D; true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable&lt;any&gt; {
    if(result !&#x3D;&#x3D; null &amp;&amp; result !&#x3D;&#x3D; undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable&lt;string&gt; {
    return new Observable&lt;string&gt;((observer: any) &#x3D;&gt; {
        if (!blob) {
            observer.next(&quot;&quot;);
            observer.complete();
        } else {
            let reader &#x3D; new FileReader(); 
            reader.onload &#x3D; function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'IRanking_penalty.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <script src="../js/menu-wc.js"></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
