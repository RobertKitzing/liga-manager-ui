{
  "version": 3,
  "sources": ["../../../../../../node_modules/@wry/equality/lib/index.js", "../../../../../../node_modules/@apollo/client/core/equalByQuery.js", "../../../../../../node_modules/@apollo/client/masking/utils.js", "../../../../../../node_modules/@apollo/client/masking/maskDefinition.js", "../../../../../../node_modules/@apollo/client/masking/maskFragment.js", "../../../../../../node_modules/@apollo/client/masking/maskOperation.js", "../../../../../../node_modules/@apollo/client/cache/core/cache.js", "../../../../../../node_modules/@apollo/client/cache/core/types/Cache.js", "../../../../../../node_modules/@apollo/client/cache/core/types/common.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/helpers.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/entityStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/object-canon.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/readFromStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/reactiveVars.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/key-extractor.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/policies.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/writeToStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js"],
  "sourcesContent": ["const {\n  toString,\n  hasOwnProperty\n} = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map();\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a, b) {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n// Allow default imports as well.\nexport default equal;\nfunction check(a, b) {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n    // Fall through to object case...\n    case '[object Object]':\n      {\n        if (previouslyCompared(a, b)) return true;\n        const aKeys = definedKeys(a);\n        const bKeys = definedKeys(b);\n        // If `a` and `b` have a different number of enumerable keys, they\n        // must be different.\n        const keyCount = aKeys.length;\n        if (keyCount !== bKeys.length) return false;\n        // Now make sure they have the same keys.\n        for (let k = 0; k < keyCount; ++k) {\n          if (!hasOwnProperty.call(b, aKeys[k])) {\n            return false;\n          }\n        }\n        // Finally, check deep equality of all child properties.\n        for (let k = 0; k < keyCount; ++k) {\n          const key = aKeys[k];\n          if (!check(a[key], b[key])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n    // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n    case '[object Map]':\n    case '[object Set]':\n      {\n        if (a.size !== b.size) return false;\n        if (previouslyCompared(a, b)) return true;\n        const aIterator = a.entries();\n        const isMap = aTag === '[object Map]';\n        while (true) {\n          const info = aIterator.next();\n          if (info.done) break;\n          // If a instanceof Set, aValue === aKey.\n          const [aKey, aValue] = info.value;\n          // So this works the same way for both Set and Map.\n          if (!b.has(aKey)) {\n            return false;\n          }\n          // However, we care about deep equality of values only when dealing\n          // with Map structures.\n          if (isMap && !check(aValue, b.get(aKey))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    case '[object Uint16Array]':\n    case '[object Uint8Array]': // Buffer, in Node.js.\n    case '[object Uint32Array]':\n    case '[object Int32Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object ArrayBuffer]':\n      // DataView doesn't need these conversions, but the equality check is\n      // otherwise the same.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // Fall through...\n    case '[object DataView]':\n      {\n        let len = a.byteLength;\n        if (len === b.byteLength) {\n          while (len-- && a[len] === b[len]) {\n            // Keep looping as long as the bytes are equal.\n          }\n        }\n        return len === -1;\n      }\n    case '[object AsyncFunction]':\n    case '[object GeneratorFunction]':\n    case '[object AsyncGeneratorFunction]':\n    case '[object Function]':\n      {\n        const aCode = fnToStr.call(a);\n        if (aCode !== fnToStr.call(b)) {\n          return false;\n        }\n        // We consider non-native functions equal if they have the same code\n        // (native functions require === because their code is censored).\n        // Note that this behavior is not entirely sound, since !== function\n        // objects with the same code can behave differently depending on\n        // their closure scope. However, any function can behave differently\n        // depending on the values of its input arguments (including this)\n        // and its calling context (including its closure scope), even\n        // though the function object is === to itself; and it is entirely\n        // possible for functions that are not === to behave exactly the\n        // same under all conceivable circumstances. Because none of these\n        // factors are statically decidable in JavaScript, JS function\n        // equality is not well-defined. This ambiguity allows us to\n        // consider the best possible heuristic among various imperfect\n        // options, and equating non-native functions that have the same\n        // code has enormous practical benefits, such as when comparing\n        // functions that are repeatedly passed as fresh function\n        // expressions within objects that are otherwise deeply equal. Since\n        // any function created from the same syntactic expression (in the\n        // same code location) will always stringify to the same code\n        // according to fnToStr.call, we can reasonably expect these\n        // repeatedly passed function expressions to have the same code, and\n        // thus behave \"the same\" (with all the caveats mentioned above),\n        // even though the runtime function objects are !== to one another.\n        return !endsWith(aCode, nativeCodeSuffix);\n      }\n  }\n  // Otherwise the values are not equal.\n  return false;\n}\nfunction definedKeys(obj) {\n  // Remember that the second argument to Array.prototype.filter will be\n  // used as `this` within the callback function.\n  return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey(key) {\n  return this[key] !== void 0;\n}\nconst nativeCodeSuffix = \"{ [native code] }\";\nfunction endsWith(full, suffix) {\n  const fromIndex = full.length - suffix.length;\n  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;\n}\nfunction previouslyCompared(a, b) {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set());\n  }\n  bSet.add(b);\n  return false;\n}\n", "import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n  var aData = _a.data,\n    aRest = __rest(_a, [\"data\"]);\n  var bData = _b.data,\n    bRest = __rest(_b, [\"data\"]);\n  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n    variables: variables\n  });\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n  if (aResult === bResult) {\n    return true;\n  }\n  var seenSelections = new Set();\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every(function (selection) {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n    if (isField(selection)) {\n      var resultKey = resultKeyNameFromField(selection);\n      var aResultChild = aResult && aResult[resultKey];\n      var bResultChild = bResult && bResult[resultKey];\n      var childSelectionSet = selection.selectionSet;\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n      var aChildIsArray = Array.isArray(aResultChild);\n      var bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        var length_1 = aResultChild.length;\n        if (bResultChild.length !== length_1) {\n          return false;\n        }\n        for (var i = 0; i < length_1; ++i) {\n          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n    } else {\n      var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n        return equalBySelectionSet(fragment.selectionSet,\n        // Notice that we reuse the same aResult and bResult values here,\n        // since the fragment ...spread does not specify a field name, but\n        // consists of multiple fields (within the fragment's selection set)\n        // that should be applied to the current result value(s).\n        aResult, bResult, context);\n      }\n    }\n  });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n  return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\nfunction directiveIsNonreactive(dir) {\n  return dir.name.value === \"nonreactive\";\n}\n", "import { Slot } from \"optimism\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { canUseWeakMap, canUseWeakSet } from \"../utilities/index.js\";\nexport var MapImpl = canUseWeakMap ? WeakMap : Map;\nexport var SetImpl = canUseWeakSet ? WeakSet : Set;\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/** @internal */\nexport var disableWarningsSlot = new Slot();\nvar issuedWarning = false;\nexport function warnOnImproperCacheImplementation() {\n  if (!issuedWarning) {\n    issuedWarning = true;\n    globalThis.__DEV__ !== false && invariant.warn(52);\n  }\n}\n", "import { Kind } from \"graphql\";\nimport { getFragmentMaskMode, maybeDeepFreeze, resultKeyNameFromField } from \"../utilities/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, function () {\n    var masked = maskSelectionSet(data, selectionSet, context, false);\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n  var mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  var _a;\n  var knownChanged = context.knownChanged;\n  var memo = getMutableTarget(data, context.mutableTargets);\n  if (Array.isArray(data)) {\n    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {\n      var _c = _b[_i],\n        index = _c[0],\n        item = _c[1];\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \"[\").concat(index, \"]\") : void 0);\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n      memo[index] = masked;\n    }\n    return knownChanged.has(memo) ? memo : data;\n  }\n  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {\n    var selection = _e[_d];\n    var value = void 0;\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n    if (selection.kind === Kind.FIELD) {\n      var keyName = resultKeyNameFromField(selection);\n      var childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n      if (value === void 0) {\n        continue;\n      }\n      if (childSelectionSet && value !== null) {\n        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \".\").concat(keyName) : void 0);\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n      if (!(globalThis.__DEV__ !== false)) {\n        memo[keyName] = value;\n      }\n      if (globalThis.__DEV__ !== false) {\n        if (migration && keyName !== \"__typename\" &&\n        // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      var fragmentName = selection.name.value;\n      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 47, fragmentName);\n      var mode = getFragmentMaskMode(selection);\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n  return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  var getValue = function () {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n    globalThis.__DEV__ !== false && invariant.warn(48, operationName ? \"\".concat(operationType, \" '\").concat(operationName, \"'\") : \"anonymous \".concat(operationType), \"\".concat(path, \".\").concat(fieldName).replace(/^\\./, \"\"));\n    getValue = function () {\n      return value;\n    };\n    return value;\n  };\n  return {\n    get: function () {\n      return getValue();\n    },\n    set: function (newValue) {\n      getValue = function () {\n        return newValue;\n      };\n    },\n    enumerable: true,\n    configurable: true\n  };\n}\n", "import { Kind } from \"graphql\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { createFragmentMap, getFragmentDefinitions } from \"../utilities/index.js\";\n/** @internal */\nexport function maskFragment(data, document, cache, fragmentName) {\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n    return data;\n  }\n  var fragments = document.definitions.filter(function (node) {\n    return node.kind === Kind.FRAGMENT_DEFINITION;\n  });\n  if (typeof fragmentName === \"undefined\") {\n    invariant(fragments.length === 1, 49, fragments.length);\n    fragmentName = fragments[0].name.value;\n  }\n  var fragment = fragments.find(function (fragment) {\n    return fragment.name.value === fragmentName;\n  });\n  invariant(!!fragment, 50, fragmentName);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\nimport { createFragmentMap, getFragmentDefinitions, getOperationDefinition } from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\n/** @internal */\nexport function maskOperation(data, document, cache) {\n  var _a;\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n    return data;\n  }\n  var definition = getOperationDefinition(document);\n  invariant(definition, 51);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { wrap } from \"optimism\";\nimport { Observable, cacheSizes, getFragmentDefinition, getFragmentQueryDocument, mergeDeepArray } from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { maskFragment } from \"../../masking/index.js\";\nvar ApolloCache = /** @class */function () {\n  function ApolloCache() {\n    this.assumeImmutableResults = false;\n    // Make sure we compute the same (===) fragment query document every\n    // time we receive the same fragment in readFragment.\n    this.getFragmentDoc = wrap(getFragmentQueryDocument, {\n      max: cacheSizes[\"cache.fragmentQueryDocuments\"] || 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n      cache: WeakCache\n    });\n  }\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  ApolloCache.prototype.lookupFragment = function (fragmentName) {\n    return null;\n  };\n  // Transactional API\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  ApolloCache.prototype.batch = function (options) {\n    var _this = this;\n    var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic : options.optimistic === false ? null : void 0;\n    var updateResult;\n    this.performTransaction(function () {\n      return updateResult = options.update(_this);\n    }, optimisticId);\n    return updateResult;\n  };\n  ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {\n    this.performTransaction(transaction, optimisticId);\n  };\n  // Optional API\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  ApolloCache.prototype.transformDocument = function (document) {\n    return document;\n  };\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  ApolloCache.prototype.transformForLink = function (document) {\n    return document;\n  };\n  ApolloCache.prototype.identify = function (object) {\n    return;\n  };\n  ApolloCache.prototype.gc = function () {\n    return [];\n  };\n  ApolloCache.prototype.modify = function (options) {\n    return false;\n  };\n  // DataProxy API\n  ApolloCache.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = !!options.optimistic;\n    }\n    return this.read(__assign(__assign({}, options), {\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic: optimistic\n    }));\n  };\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  ApolloCache.prototype.watchFragment = function (options) {\n    var _this = this;\n    var fragment = options.fragment,\n      fragmentName = options.fragmentName,\n      from = options.from,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      otherOptions = __rest(options, [\"fragment\", \"fragmentName\", \"from\", \"optimistic\"]);\n    var query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    var id = typeof from === \"undefined\" || typeof from === \"string\" ? from : this.identify(from);\n    var dataMasking = !!options[Symbol.for(\"apollo.dataMasking\")];\n    if (globalThis.__DEV__ !== false) {\n      var actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;\n      if (!id) {\n        globalThis.__DEV__ !== false && invariant.warn(1, actualFragmentName);\n      }\n    }\n    var diffOptions = __assign(__assign({}, otherOptions), {\n      returnPartialData: true,\n      id: id,\n      query: query,\n      optimistic: optimistic\n    });\n    var latestDiff;\n    return new Observable(function (observer) {\n      return _this.watch(__assign(__assign({}, diffOptions), {\n        immediate: true,\n        callback: function (diff) {\n          var data = dataMasking ? maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;\n          if (\n          // Always ensure we deliver the first result\n          latestDiff && equalByQuery(query, {\n            data: latestDiff.result\n          }, {\n            data: data\n          },\n          // TODO: Fix the type on WatchFragmentOptions so that TVars\n          // extends OperationVariables\n          options.variables)) {\n            return;\n          }\n          var result = {\n            data: data,\n            complete: !!diff.complete\n          };\n          if (diff.missing) {\n            result.missing = mergeDeepArray(diff.missing.map(function (error) {\n              return error.missing;\n            }));\n          }\n          latestDiff = __assign(__assign({}, diff), {\n            result: data\n          });\n          observer.next(result);\n        }\n      }));\n    });\n  };\n  ApolloCache.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = !!options.optimistic;\n    }\n    return this.read(__assign(__assign({}, options), {\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic: optimistic\n    }));\n  };\n  ApolloCache.prototype.writeQuery = function (_a) {\n    var id = _a.id,\n      data = _a.data,\n      options = __rest(_a, [\"id\", \"data\"]);\n    return this.write(Object.assign(options, {\n      dataId: id || \"ROOT_QUERY\",\n      result: data\n    }));\n  };\n  ApolloCache.prototype.writeFragment = function (_a) {\n    var id = _a.id,\n      data = _a.data,\n      fragment = _a.fragment,\n      fragmentName = _a.fragmentName,\n      options = __rest(_a, [\"id\", \"data\", \"fragment\", \"fragmentName\"]);\n    return this.write(Object.assign(options, {\n      query: this.getFragmentDoc(fragment, fragmentName),\n      dataId: id,\n      result: data\n    }));\n  };\n  ApolloCache.prototype.updateQuery = function (options, update) {\n    return this.batch({\n      update: function (cache) {\n        var value = cache.readQuery(options);\n        var data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery(__assign(__assign({}, options), {\n          data: data\n        }));\n        return data;\n      }\n    });\n  };\n  ApolloCache.prototype.updateFragment = function (options, update) {\n    return this.batch({\n      update: function (cache) {\n        var value = cache.readFragment(options);\n        var data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment(__assign(__assign({}, options), {\n          data: data\n        }));\n        return data;\n      }\n    });\n  };\n  return ApolloCache;\n}();\nexport { ApolloCache };\nif (globalThis.__DEV__ !== false) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n", "export var Cache;\n(function (Cache) {})(Cache || (Cache = {}));\n", "import { __extends } from \"tslib\";\nvar MissingFieldError = /** @class */function (_super) {\n  __extends(MissingFieldError, _super);\n  function MissingFieldError(message, path, query, variables) {\n    var _a;\n    // 'Error' breaks prototype chain here\n    var _this = _super.call(this, message) || this;\n    _this.message = message;\n    _this.path = path;\n    _this.query = query;\n    _this.variables = variables;\n    if (Array.isArray(_this.path)) {\n      _this.missing = _this.message;\n      for (var i = _this.path.length - 1; i >= 0; --i) {\n        _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);\n      }\n    } else {\n      _this.missing = _this.path;\n    }\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    _this.__proto__ = MissingFieldError.prototype;\n    return _this;\n  }\n  return MissingFieldError;\n}(Error);\nexport { MissingFieldError };\n", "import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n  return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n    id = _a.id,\n    _id = _a._id;\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id) ? {\n        id: id\n      } : !isNullish(_id) ? {\n        _id: _id\n      } : void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n    if (!isNullish(id)) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n      // If the selection has been skipped with @skip(true) or\n      // @include(false), it should not count against the matching. If\n      // the selection is not a field, it must be a fragment (inline or\n      // named). We will determine if selectionSetMatchesResult for that\n      // fragment when we get to it, so for now we return true.\n      return true;\n    });\n  }\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap: fragmentMap,\n    lookupFragment: function (name) {\n      var def = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    }\n  };\n}\n", "import { __assign, __extends, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = Object.create(null);\nvar delModifier = function () {\n  return DELETE;\n};\nvar INVALIDATE = Object.create(null);\nvar EntityStore = /** @class */function () {\n  function EntityStore(policies, group) {\n    var _this = this;\n    this.policies = policies;\n    this.group = group;\n    this.data = Object.create(null);\n    // Maps root entity IDs to the number of times they have been retained, minus\n    // the number of times they have been released. Retained entities keep other\n    // entities they reference (even indirectly) from being garbage collected.\n    this.rootIds = Object.create(null);\n    // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n    this.refs = Object.create(null);\n    // Bound function that can be passed around to provide easy access to fields\n    // of Reference objects as well as ordinary objects.\n    this.getFieldValue = function (objectOrReference, storeFieldName) {\n      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);\n    };\n    // Returns true for non-normalized StoreObjects and non-dangling\n    // References, indicating that readField(name, objOrRef) has a chance of\n    // working. Useful for filtering out dangling references from lists.\n    this.canRead = function (objOrRef) {\n      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === \"object\";\n    };\n    // Bound function that converts an id or an object with a __typename and\n    // primary key fields to a Reference object. If called with a Reference object,\n    // that same Reference object is returned. Pass true for mergeIntoStore to persist\n    // an object into the store.\n    this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n      if (typeof objOrIdOrRef === \"string\") {\n        return makeReference(objOrIdOrRef);\n      }\n      if (isReference(objOrIdOrRef)) {\n        return objOrIdOrRef;\n      }\n      var id = _this.policies.identify(objOrIdOrRef)[0];\n      if (id) {\n        var ref = makeReference(id);\n        if (mergeIntoStore) {\n          _this.merge(id, objOrIdOrRef);\n        }\n        return ref;\n      }\n    };\n  }\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n  EntityStore.prototype.toObject = function () {\n    return __assign({}, this.data);\n  };\n  EntityStore.prototype.has = function (dataId) {\n    return this.lookup(dataId, true) !== void 0;\n  };\n  EntityStore.prototype.get = function (dataId, fieldName) {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      var storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (fieldName === \"__typename\" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  };\n  EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  };\n  EntityStore.prototype.merge = function (older, newer) {\n    var _this = this;\n    var dataId;\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n    var existing = typeof older === \"string\" ? this.lookup(dataId = older) : older;\n    var incoming = typeof newer === \"string\" ? this.lookup(dataId = newer) : newer;\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n    invariant(typeof dataId === \"string\", 2);\n    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        var fieldsToDirty_1 = Object.create(null);\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty_1.__exists = 1;\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach(function (storeFieldName) {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty_1[storeFieldName] = 1;\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty_1[fieldName] = 1;\n            }\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n        if (fieldsToDirty_1.__typename && !(existing && existing.__typename) &&\n        // Since we return default root __typename strings\n        // automatically from store.get, we don't need to dirty the\n        // ROOT_QUERY.__typename field if merged.__typename is equal\n        // to the default string (usually \"Query\").\n        this.policies.rootTypenamesById[dataId] === merged.__typename) {\n          delete fieldsToDirty_1.__typename;\n        }\n        Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\n          return _this.group.dirty(dataId, fieldName);\n        });\n      }\n    }\n  };\n  EntityStore.prototype.modify = function (dataId, fields) {\n    var _this = this;\n    var storeObject = this.lookup(dataId);\n    if (storeObject) {\n      var changedFields_1 = Object.create(null);\n      var needToMerge_1 = false;\n      var allDeleted_1 = true;\n      var sharedDetails_1 = {\n        DELETE: DELETE,\n        INVALIDATE: INVALIDATE,\n        isReference: isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: function (fieldNameOrOptions, from) {\n          return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId)\n          } : fieldNameOrOptions, {\n            store: _this\n          });\n        }\n      };\n      Object.keys(storeObject).forEach(function (storeFieldName) {\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        var modify = typeof fields === \"function\" ? fields : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), {\n            fieldName: fieldName,\n            storeFieldName: storeFieldName,\n            storage: _this.getStorage(dataId, storeFieldName)\n          }));\n          if (newValue === INVALIDATE) {\n            _this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields_1[storeFieldName] = newValue;\n              needToMerge_1 = true;\n              fieldValue = newValue;\n              if (globalThis.__DEV__ !== false) {\n                var checkReference = function (ref) {\n                  if (_this.lookup(ref.__ref) === undefined) {\n                    globalThis.__DEV__ !== false && invariant.warn(3, ref);\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  var seenReference = false;\n                  var someNonReference = void 0;\n                  for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {\n                    var value = newValue_1[_i];\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        var id = _this.policies.identify(value)[0];\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      globalThis.__DEV__ !== false && invariant.warn(4, someNonReference);\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted_1 = false;\n        }\n      });\n      if (needToMerge_1) {\n        this.merge(dataId, changedFields_1);\n        if (allDeleted_1) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  EntityStore.prototype.delete = function (dataId, fieldName, args) {\n    var _a;\n    var storeObject = this.lookup(dataId);\n    if (storeObject) {\n      var typename = this.getFieldValue(storeObject, \"__typename\");\n      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({\n        typename: typename,\n        fieldName: fieldName,\n        args: args\n      }) : fieldName;\n      return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);\n    }\n    return false;\n  };\n  EntityStore.prototype.evict = function (options, limit) {\n    var evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  };\n  EntityStore.prototype.clear = function () {\n    this.replace(null);\n  };\n  EntityStore.prototype.extract = function () {\n    var _this = this;\n    var obj = this.toObject();\n    var extraRootIds = [];\n    this.getRootIdSet().forEach(function (id) {\n      if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = {\n        extraRootIds: extraRootIds.sort()\n      };\n    }\n    return obj;\n  };\n  EntityStore.prototype.replace = function (newData) {\n    var _this = this;\n    Object.keys(this.data).forEach(function (dataId) {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        _this.delete(dataId);\n      }\n    });\n    if (newData) {\n      var __META = newData.__META,\n        rest_1 = __rest(newData, [\"__META\"]);\n      Object.keys(rest_1).forEach(function (dataId) {\n        _this.merge(dataId, rest_1[dataId]);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  };\n  EntityStore.prototype.retain = function (rootId) {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  };\n  EntityStore.prototype.release = function (rootId) {\n    if (this.rootIds[rootId] > 0) {\n      var count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  };\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  EntityStore.prototype.getRootIdSet = function (ids) {\n    if (ids === void 0) {\n      ids = new Set();\n    }\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  };\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  EntityStore.prototype.gc = function () {\n    var _this = this;\n    var ids = this.getRootIdSet();\n    var snapshot = this.toObject();\n    ids.forEach(function (id) {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    var idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      var root_1 = this;\n      while (root_1 instanceof Layer) root_1 = root_1.parent;\n      idsToRemove.forEach(function (id) {\n        return root_1.delete(id);\n      });\n    }\n    return idsToRemove;\n  };\n  EntityStore.prototype.findChildRefIds = function (dataId) {\n    if (!hasOwn.call(this.refs, dataId)) {\n      var found_1 = this.refs[dataId] = Object.create(null);\n      var root = this.data[dataId];\n      if (!root) return found_1;\n      var workSet_1 = new Set([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet_1.forEach(function (obj) {\n        if (isReference(obj)) {\n          found_1[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach(function (key) {\n            var child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet_1.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  };\n  EntityStore.prototype.makeCacheKey = function () {\n    return this.group.keyMaker.lookupArray(arguments);\n  };\n  return EntityStore;\n}();\nexport { EntityStore };\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nvar CacheGroup = /** @class */function () {\n  function CacheGroup(caching, parent) {\n    if (parent === void 0) {\n      parent = null;\n    }\n    this.caching = caching;\n    this.parent = parent;\n    this.d = null;\n    this.resetCaching();\n  }\n  CacheGroup.prototype.resetCaching = function () {\n    this.d = this.caching ? dep() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  };\n  CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      var fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  };\n  CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d.dirty(makeDepKey(dataId, storeFieldName),\n      // When storeFieldName === \"__exists\", that means the entity identified\n      // by dataId has either disappeared from the cache or was newly added,\n      // so the result caching system would do well to \"forget everything it\n      // knows\" about that object. To achieve that kind of invalidation, we\n      // not only dirty the associated result cache entry, but also remove it\n      // completely from the dependency graph. For the optimism implementation\n      // details, see https://github.com/benjamn/optimism/pull/195.\n      storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n    }\n  };\n  return CacheGroup;\n}();\nfunction makeDepKey(dataId, storeFieldName) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n(function (EntityStore) {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  var Root = /** @class */function (_super) {\n    __extends(Root, _super);\n    function Root(_a) {\n      var policies = _a.policies,\n        _b = _a.resultCaching,\n        resultCaching = _b === void 0 ? true : _b,\n        seed = _a.seed;\n      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n      _this.stump = new Stump(_this);\n      _this.storageTrie = new Trie(canUseWeakMap);\n      if (seed) _this.replace(seed);\n      return _this;\n    }\n    Root.prototype.addLayer = function (layerId, replay) {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    };\n    Root.prototype.removeLayer = function () {\n      // Never remove the root layer.\n      return this;\n    };\n    Root.prototype.getStorage = function () {\n      return this.storageTrie.lookupArray(arguments);\n    };\n    return Root;\n  }(EntityStore);\n  EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nvar Layer = /** @class */function (_super) {\n  __extends(Layer, _super);\n  function Layer(id, parent, replay, group) {\n    var _this = _super.call(this, parent.policies, group) || this;\n    _this.id = id;\n    _this.parent = parent;\n    _this.replay = replay;\n    _this.group = group;\n    replay(_this);\n    return _this;\n  }\n  Layer.prototype.addLayer = function (layerId, replay) {\n    return new Layer(layerId, this, replay, this.group);\n  };\n  Layer.prototype.removeLayer = function (layerId) {\n    var _this = this;\n    // Remove all instances of the given id, not just the first one.\n    var parent = this.parent.removeLayer(layerId);\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach(function (dataId) {\n          var ownStoreObject = _this.data[dataId];\n          var parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            _this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            _this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach(function (storeFieldName) {\n              _this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach(function (storeFieldName) {\n              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                _this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n      return parent;\n    }\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  };\n  Layer.prototype.toObject = function () {\n    return __assign(__assign({}, this.parent.toObject()), this.data);\n  };\n  Layer.prototype.findChildRefIds = function (dataId) {\n    var fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n  };\n  Layer.prototype.getStorage = function () {\n    var p = this.parent;\n    while (p.parent) p = p.parent;\n    return p.getStorage.apply(p,\n    // @ts-expect-error\n    arguments);\n  };\n  return Layer;\n}(EntityStore);\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nvar Stump = /** @class */function (_super) {\n  __extends(Stump, _super);\n  function Stump(root) {\n    return _super.call(this, \"EntityStore.Stump\", root, function () {}, new CacheGroup(root.group.caching, root.group)) || this;\n  }\n  Stump.prototype.removeLayer = function () {\n    // Never remove the Stump layer.\n    return this;\n  };\n  Stump.prototype.merge = function (older, newer) {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge(older, newer);\n  };\n  return Stump;\n}(Layer);\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n  var existingValue = existingObject[property];\n  var incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n", "import { __assign } from \"tslib\";\nimport { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet, isNonNullObject as isObjectOrArray } from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\nfunction shallowCopy(value) {\n  if (isObjectOrArray(value)) {\n    return isArray(value) ? value.slice(0) : __assign({\n      __proto__: Object.getPrototypeOf(value)\n    }, value);\n  }\n  return value;\n}\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nvar ObjectCanon = /** @class */function () {\n  function ObjectCanon() {\n    // Set of all canonical objects this ObjectCanon has admitted, allowing\n    // canon.admit to return previously-canonicalized objects immediately.\n    this.known = new (canUseWeakSet ? WeakSet : Set)();\n    // Efficient storage/lookup structure for canonical objects.\n    this.pool = new Trie(canUseWeakMap);\n    // Make the ObjectCanon assume this value has already been\n    // canonicalized.\n    this.passes = new WeakMap();\n    // Arrays that contain the same elements in a different order can share\n    // the same SortedKeysInfo object, to save memory.\n    this.keysByJSON = new Map();\n    // This has to come last because it depends on keysByJSON.\n    this.empty = this.admit({});\n  }\n  ObjectCanon.prototype.isKnown = function (value) {\n    return isObjectOrArray(value) && this.known.has(value);\n  };\n  ObjectCanon.prototype.pass = function (value) {\n    if (isObjectOrArray(value)) {\n      var copy = shallowCopy(value);\n      this.passes.set(copy, value);\n      return copy;\n    }\n    return value;\n  };\n  ObjectCanon.prototype.admit = function (value) {\n    var _this = this;\n    if (isObjectOrArray(value)) {\n      var original = this.passes.get(value);\n      if (original) return original;\n      var proto = Object.getPrototypeOf(value);\n      switch (proto) {\n        case Array.prototype:\n          {\n            if (this.known.has(value)) return value;\n            var array = value.map(this.admit, this);\n            // Arrays are looked up in the Trie using their recursively\n            // canonicalized elements, and the known version of the array is\n            // preserved as node.array.\n            var node = this.pool.lookupArray(array);\n            if (!node.array) {\n              this.known.add(node.array = array);\n              // Since canonical arrays may be shared widely between\n              // unrelated consumers, it's important to regard them as\n              // immutable, even if they are not frozen in production.\n              if (globalThis.__DEV__ !== false) {\n                Object.freeze(array);\n              }\n            }\n            return node.array;\n          }\n        case null:\n        case Object.prototype:\n          {\n            if (this.known.has(value)) return value;\n            var proto_1 = Object.getPrototypeOf(value);\n            var array_1 = [proto_1];\n            var keys = this.sortedKeys(value);\n            array_1.push(keys.json);\n            var firstValueIndex_1 = array_1.length;\n            keys.sorted.forEach(function (key) {\n              array_1.push(_this.admit(value[key]));\n            });\n            // Objects are looked up in the Trie by their prototype (which\n            // is *not* recursively canonicalized), followed by a JSON\n            // representation of their (sorted) keys, followed by the\n            // sequence of recursively canonicalized values corresponding to\n            // those keys. To keep the final results unambiguous with other\n            // sequences (such as arrays that just happen to contain [proto,\n            // keys.json, value1, value2, ...]), the known version of the\n            // object is stored as node.object.\n            var node = this.pool.lookupArray(array_1);\n            if (!node.object) {\n              var obj_1 = node.object = Object.create(proto_1);\n              this.known.add(obj_1);\n              keys.sorted.forEach(function (key, i) {\n                obj_1[key] = array_1[firstValueIndex_1 + i];\n              });\n              // Since canonical objects may be shared widely between\n              // unrelated consumers, it's important to regard them as\n              // immutable, even if they are not frozen in production.\n              if (globalThis.__DEV__ !== false) {\n                Object.freeze(obj_1);\n              }\n            }\n            return node.object;\n          }\n      }\n    }\n    return value;\n  };\n  // It's worthwhile to cache the sorting of arrays of strings, since the\n  // same initial unsorted arrays tend to be encountered many times.\n  // Fortunately, we can reuse the Trie machinery to look up the sorted\n  // arrays in linear time (which is faster than sorting large arrays).\n  ObjectCanon.prototype.sortedKeys = function (obj) {\n    var keys = Object.keys(obj);\n    var node = this.pool.lookupArray(keys);\n    if (!node.keys) {\n      keys.sort();\n      var json = JSON.stringify(keys);\n      if (!(node.keys = this.keysByJSON.get(json))) {\n        this.keysByJSON.set(json, node.keys = {\n          sorted: keys,\n          json: json\n        });\n      }\n    }\n    return node.keys;\n  };\n  return ObjectCanon;\n}();\nexport { ObjectCanon };\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context,\n  // We split out this property so we can pass different values\n  // independently without modifying options.context itself.\n  options.context.canonizeResults];\n}\nvar StoreReader = /** @class */function () {\n  function StoreReader(config) {\n    var _this = this;\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config)\n    });\n    this.canon = config.canon || new ObjectCanon();\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n      peekArgs[3] = !canonizeResults;\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: _this.canon.admit(other.result)\n          });\n        }\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n          array = _a.array,\n          context = _a.context;\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n      query = _a.query,\n      _b = _a.rootId,\n      rootId = _b === void 0 ? \"ROOT_QUERY\" : _b,\n      variables = _a.variables,\n      _c = _a.returnPartialData,\n      returnPartialData = _c === void 0 ? true : _c,\n      _d = _a.canonizeResults,\n      canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: __assign({\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults\n      }, extractFragmentContext(query, this.config.fragments))\n    });\n    var missing;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing: missing\n    };\n  };\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context,\n      // If result is canonical, then it could only have been previously\n      // cached by the canonizing version of executeSelectionSet, so we can\n      // avoid checking both possibilities here.\n      this.canon.isKnown(result));\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  };\n  // Uncached version of executeSelectionSet.\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n    var selectionSet = _a.selectionSet,\n      objectOrReference = _a.objectOrReference,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n    var variables = context.variables,\n      policies = context.policies,\n      store = context.store;\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    var objectsToMerge = [];\n    var missing;\n    var missingMerger = new DeepMerger();\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n    function handleMissing(result, resultName) {\n      var _a;\n      if (result.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n      }\n      return result.result;\n    }\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a, _b;\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(_this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef: enclosingRef,\n              context: context\n            }), resultName);\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }), resultName);\n        }\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(10, selection.name.value);\n        }\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var result = mergeDeepArray(objectsToMerge);\n    var finalResult = {\n      result: result,\n      missing: missing\n    };\n    var frozen = context.canonizeResults ? this.canon.admit(finalResult)\n    // Since this.canon is normally responsible for freezing results (only in\n    // development), freeze them manually if canonization is disabled.\n    : maybeDeepFreeze(finalResult);\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n    return frozen;\n  };\n  // Uncached version of executeSubSelectedArray.\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n    var field = _a.field,\n      array = _a.array,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    var missing;\n    var missingMerger = new DeepMerger();\n    function handleMissing(childResult, i) {\n      var _a;\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n      }\n      return childResult.result;\n    }\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n    array = array.map(function (item, i) {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n      if (globalThis.__DEV__ !== false) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n  return StoreReader;\n}();\nexport { StoreReader };\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function (_, value) {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        invariant(!isReference(value), 11, getTypenameFromStoreObject(store, value), field.name.value);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}\n", "import { dep, Slot } from \"optimism\";\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport var cacheSlot = new Slot();\nvar cacheInfoMap = new WeakMap();\nfunction getCacheInfo(cache) {\n  var info = cacheInfoMap.get(cache);\n  if (!info) {\n    cacheInfoMap.set(cache, info = {\n      vars: new Set(),\n      dep: dep()\n    });\n  }\n  return info;\n}\nexport function forgetCache(cache) {\n  getCacheInfo(cache).vars.forEach(function (rv) {\n    return rv.forgetCache(cache);\n  });\n}\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache) {\n  getCacheInfo(cache).vars.forEach(function (rv) {\n    return rv.attachCache(cache);\n  });\n}\nexport function makeVar(value) {\n  var caches = new Set();\n  var listeners = new Set();\n  var rv = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue;\n        caches.forEach(function (cache) {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        var oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach(function (listener) {\n          return listener(value);\n        });\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      var cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n    return value;\n  };\n  rv.onNextChange = function (listener) {\n    listeners.add(listener);\n    return function () {\n      listeners.delete(listener);\n    };\n  };\n  var attach = rv.attachCache = function (cache) {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  };\n  rv.forgetCache = function (cache) {\n    return caches.delete(cache);\n  };\n  return rv;\n}\nfunction broadcast(cache) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, isArray } from \"./helpers.js\";\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nvar specifierInfoCache = Object.create(null);\nfunction lookupSpecifierInfo(spec) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  var cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null));\n}\nexport function keyFieldsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n    var extract = function (from, key) {\n      return context.readField(key, from);\n    };\n    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n      var extracted = extractKeyPath(context.storeObject, schemaKeyPath,\n      // Using context.readField to extract paths from context.storeObject\n      // allows the extraction to see through Reference objects and respect\n      // custom read functions.\n      extract);\n      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {\n        // If context.storeObject fails to provide a value for the requested\n        // path, fall back to the raw result object, if it has a top-level key\n        // matching the first key in the path (schemaKeyPath[0]). This allows\n        // key fields included in the written data to be saved in the cache\n        // even if they are not selected explicitly in context.selectionSet.\n        // Not being mentioned by context.selectionSet is convenient here,\n        // since it means these extra fields cannot be affected by field\n        // aliasing, which is why we can use extractKey instead of\n        // context.readField for this extraction.\n        extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n      }\n      invariant(extracted !== void 0, 5, schemaKeyPath.join(\".\"), object);\n      return extracted;\n    });\n    return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n  });\n}\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n    var field = _a.field,\n      variables = _a.variables,\n      fieldName = _a.fieldName;\n    var collected = collectSpecifierPaths(specifier, function (keyPath) {\n      var firstKey = keyPath[0];\n      var firstChar = firstKey.charAt(0);\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          var directiveName_1 = firstKey.slice(1);\n          // If the directive appears multiple times, only the first\n          // occurrence's arguments will be used. TODO Allow repetition?\n          // TODO Cache this work somehow, a la aliasMap?\n          var d = field.directives.find(function (d) {\n            return d.name.value === directiveName_1;\n          });\n          // Fortunately argumentsObjectFromField works for DirectiveNode!\n          var directiveArgs = d && argumentsObjectFromField(d, variables);\n          // For directives without arguments (d defined, but directiveArgs ===\n          // null), the presence or absence of the directive still counts as\n          // part of the field key, so we return null in those cases. If no\n          // directive with this name was found for this field (d undefined and\n          // thus directiveArgs undefined), we return undefined, which causes\n          // this value to be omitted from the key object returned by\n          // collectSpecifierPaths.\n          return directiveArgs && extractKeyPath(directiveArgs,\n          // If keyPath.length === 1, this code calls extractKeyPath with an\n          // empty path, which works because it uses directiveArgs as the\n          // extracted value.\n          keyPath.slice(1));\n        }\n        // If the key started with @ but there was no corresponding directive,\n        // we want to omit this value from the key object, not fall through to\n        // treating @whatever as a normal argument name.\n        return;\n      }\n      if (firstChar === \"$\") {\n        var variableName = firstKey.slice(1);\n        if (variables && hasOwn.call(variables, variableName)) {\n          var varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n        // If the key started with $ but there was no corresponding variable, we\n        // want to omit this value from the key object, not fall through to\n        // treating $whatever as a normal argument name.\n        return;\n      }\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n    var suffix = JSON.stringify(collected);\n    // If no arguments were passed to this field, and it didn't have any other\n    // field key contributions from directives or variables, hide the empty\n    // :{} suffix from the field key. However, a field passed no arguments can\n    // still end up with a non-empty :{...} suffix if its key configuration\n    // refers to directives or variables.\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n    return fieldName;\n  });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  var merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce(function (collected, path) {\n    var _a;\n    var toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (var i = path.length - 1; i >= 0; --i) {\n        toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n  var info = lookupSpecifierInfo(spec);\n  if (!info.paths) {\n    var paths_1 = info.paths = [];\n    var currentPath_1 = [];\n    spec.forEach(function (s, i) {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach(function (p) {\n          return paths_1.push(currentPath_1.concat(p));\n        });\n        currentPath_1.length = 0;\n      } else {\n        currentPath_1.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths_1.push(currentPath_1.slice(0));\n          currentPath_1.length = 0;\n        }\n      }\n    });\n  }\n  return info.paths;\n}\nfunction extractKey(object, key) {\n  return object[key];\n}\nexport function extractKeyPath(object, path, extract) {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key) {\n    return isArray(obj) ? obj.map(function (child) {\n      return reducer(child, key);\n    }) : obj && extract(obj, key);\n  }, object));\n}\nfunction normalize(value) {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize);\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), function (path) {\n      return extractKeyPath(value, path);\n    });\n  }\n  return value;\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\nvar Policies = /** @class */function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null);\n    // Map from subtype names to sets of supertype names. Note that this\n    // representation inverts the structure of possibleTypes (whose keys are\n    // supertypes and whose values are arrays of subtypes) because it tends\n    // to be much more efficient to search upwards than downwards.\n    this.supertypeMap = new Map();\n    // Any fuzzy subtypes specified by possibleTypes will be converted to\n    // RegExp objects and recorded here. Every key of this map can also be\n    // found in supertypeMap. In many cases this Map will be empty, which\n    // means no fuzzy subtype checking will happen in fragmentMatches.\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n  Policies.prototype.identify = function (object, partialContext) {\n    var _a;\n    var policies = this;\n    var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n    // Default context.storeObject to object if not otherwise provided.\n    var storeObject = partialContext && partialContext.storeObject || object;\n    var context = __assign(__assign({}, partialContext), {\n      typename: typename,\n      storeObject: storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    disableWarningsSlot.withValue(true, function () {\n      while (keyFn) {\n        var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n        queryType = _a.queryType,\n        mutationType = _a.mutationType,\n        subscriptionType = _a.subscriptionType,\n        incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n      fields = incoming.fields;\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge\n      // Pass merge:true as a shorthand for a merge implementation\n      // that returns options.mergeObjects(existing, incoming).\n      : merge === true ? mergeTrueFn\n      // Pass merge:false to make incoming always replace existing\n      // without any warnings about data clobbering.\n      : merge === false ? mergeFalseFn : existing.merge;\n    }\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n    existing.keyFn =\n    // Pass false to disable normalization for this typename.\n    keyFields === false ? nullKeyFieldsFn\n    // Pass an array of strings to use those fields to compute a\n    // composite ID for objects of this typename.\n    : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n    // Pass a function to take full control over identification.\n    : typeof keyFields === \"function\" ? keyFields\n    // Leave existing.keyFn unchanged if above cases fail.\n    : existing.keyFn;\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n        var incoming = fields[fieldName];\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n            read = incoming.read,\n            merge = incoming.merge;\n          existing.keyFn =\n          // Pass false to disable argument-based differentiation of\n          // field identities.\n          keyArgs === false ? simpleKeyArgsFn\n          // Pass an array of strings to use named arguments to\n          // compute a composite identity for the field.\n          : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n          // Pass a function to take full control over field identity.\n          : typeof keyArgs === \"function\" ? keyArgs\n          // Leave existing.keyFn unchanged if above cases fail.\n          : existing.keyFn;\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n          setMerge(existing, merge);\n        }\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, 6, which);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      _this.getSupertypeSet(supertype, true);\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n        var match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null);\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      var supertypes_1 = this.supertypeMap.get(typename);\n      if (!supertypes_1 && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes_1 = this.getSupertypeSet(typename, true);\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach(function (supertype) {\n                return supertypes_1.add(supertype);\n              });\n            }\n          }\n        });\n      }\n      if (supertypes_1 && supertypes_1.size) {\n        supertypes_1.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n            fields = _a.fields,\n            rest = __rest(_a, [\"fields\"]);\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n    var inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(function (policy) {\n        _this.updateTypePolicy(typename, policy);\n      });\n    }\n    return this.typePolicies[typename];\n  };\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n    return supertypeSet;\n  };\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n    if (!fragment.typeCondition) return true;\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n      var maybeEnqueue_1 = function (subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              globalThis.__DEV__ !== false && invariant.warn(7, typename, supertype);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n        supertypeSet.forEach(maybeEnqueue_1);\n        if (needToCheckFuzzySubtypes &&\n        // Start checking fuzzy subtypes only after exhausting all\n        // non-fuzzy subtypes (after the final iteration of the loop).\n        i === workQueue_1.length - 1 &&\n        // We could wait to compare fragment.selectionSet to result\n        // after we verify the supertype, but this check is often less\n        // expensive than that search, and we will have to do the\n        // comparison anyway whenever we find a potential match.\n        selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n    return false;\n  };\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n      fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n    return existing;\n  };\n  Policies.prototype.getReadFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  };\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  };\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n      typename = _a.typename,\n      merge = _a.merge;\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n    return merge(existing, incoming, makeFieldFunctionOptions(this,\n    // Unlike options.readField for read functions, we do not fall\n    // back to the current object if no foreignObjOrRef is provided,\n    // because it's not clear what the current object should be for\n    // merge functions: the (possibly undefined) existing object, or\n    // the incoming object? If you think your merge function needs\n    // to read sibling fields in order to produce a new value for\n    // the current field, you might want to rethink your strategy,\n    // because that's a recipe for making merge behavior sensitive\n    // to the order in which fields are written into the cache.\n    // However, readField(name, ref) is useful for merge functions\n    // that need to deduplicate child objects and references.\n    void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n  return Policies;\n}();\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n    toReference = _a.toReference,\n    canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function () {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0],\n    from = readFieldArgs[1],\n    argc = readFieldArgs.length;\n  var options;\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions);\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n  if (globalThis.__DEV__ !== false && options.from === void 0) {\n    globalThis.__DEV__ !== false && invariant.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));\n  }\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n  return options;\n}\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(9);\n    }\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n      if (typesDiffer) {\n        return incoming;\n      }\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n    return incoming;\n  };\n}\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {\n      clientOnly: clientOnly,\n      deferred: deferred\n    }));\n  }\n  return flavored;\n}\nvar StoreWriter = /** @class */function () {\n  function StoreWriter(cache, reader, fragments) {\n    this.cache = cache;\n    this.reader = reader;\n    this.fragments = fragments;\n  }\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n    var query = _a.query,\n      result = _a.result,\n      dataId = _a.dataId,\n      variables = _a.variables,\n      overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var context = __assign(__assign({\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables)\n    }, extractFragmentContext(query, this.fragments)), {\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map()\n    });\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n    if (!isReference(ref)) {\n      throw newInvariantError(12, result);\n    }\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(function (_a, dataId) {\n      var storeObject = _a.storeObject,\n        mergeTree = _a.mergeTree,\n        fieldNodeSet = _a.fieldNodeSet;\n      var entityRef = makeReference(dataId);\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n        if (isReference(applied)) {\n          // Assume References returned by applyMerges have already been merged\n          // into the store. See makeMergeObjectsFunction in policies.ts for an\n          // example of how this can happen.\n          return;\n        }\n        // Otherwise, applyMerges returned a StoreObject, whose fields we should\n        // merge into the store (see store.merge statement below).\n        storeObject = applied;\n      }\n      if (globalThis.__DEV__ !== false && !context.overwrite) {\n        var fieldsWithSelectionSets_1 = Object.create(null);\n        fieldNodeSet.forEach(function (field) {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets_1[field.name.value] = true;\n          }\n        });\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n        };\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n        Object.keys(storeObject).forEach(function (storeFieldName) {\n          // If a merge function was defined for this field, trust that it\n          // did the right thing about (not) clobbering data. If the field\n          // has no selection set, it's a scalar field, so it doesn't need\n          // a merge function (even if it's an object, like JSON data).\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n          }\n        });\n      }\n      store.merge(dataId, storeObject);\n    });\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n    return ref;\n  };\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n    var dataId = _a.dataId,\n      result = _a.result,\n      selectionSet = _a.selectionSet,\n      context = _a.context,\n      // This object allows processSelectionSet to report useful information\n      // to its callers without explicitly returning that information.\n      mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    var incoming = Object.create(null);\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    var readField = function () {\n      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n      if (isReference(options.from)) {\n        var info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          var result_1 = policies.readField(__assign(__assign({}, options), {\n            from: info.storeObject\n          }), context);\n          if (result_1 !== void 0) {\n            return result_1;\n          }\n        }\n      }\n      return policies.readField(options, context);\n    };\n    var fieldNodeSet = new Set();\n    this.flattenFields(selectionSet, result,\n    // This WriteContext will be the default context value for fields returned\n    // by the flattenFields method, but some fields may be assigned a modified\n    // context, depending on the presence of @client and other directives.\n    context, typename).forEach(function (context, field) {\n      var _a;\n      var resultFieldKey = resultKeyNameFromField(field);\n      var value = result[resultFieldKey];\n      fieldNodeSet.add(field);\n      if (value !== void 0) {\n        var storeFieldName = policies.getStoreFieldName({\n          typename: typename,\n          fieldName: field.name.value,\n          field: field,\n          variables: context.variables\n        });\n        var childTree = getChildMergeTree(mergeTree, storeFieldName);\n        var incomingValue = _this.processFieldValue(value, field,\n        // Reset context.clientOnly and context.deferred to their default\n        // values before processing nested selection sets.\n        field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        var childTypename = void 0;\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField(\"__typename\", incomingValue);\n        }\n        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field: field,\n            typename: typename,\n            merge: merge\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n        incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n      } else if (globalThis.__DEV__ !== false && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) &&\n      // If the field has a read function, it may be a synthetic field or\n      // provide a default value, so its absence from the written data should\n      // not be cause for alarm.\n      !policies.getReadFunction(typename, field.name.value)) {\n        globalThis.__DEV__ !== false && invariant.error(13, resultKeyNameFromField(field), result);\n      }\n    });\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      var _b = policies.identify(result, {\n          typename: typename,\n          selectionSet: selectionSet,\n          fragmentMap: context.fragmentMap,\n          storeObject: incoming,\n          readField: readField\n        }),\n        id = _b[0],\n        keyObject = _b[1];\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n    if (\"string\" === typeof dataId) {\n      var dataRef = makeReference(dataId);\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n        return dataRef;\n      }\n      var previous_1 = context.incomingById.get(dataId);\n      if (previous_1) {\n        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n        fieldNodeSet.forEach(function (field) {\n          return previous_1.fieldNodeSet.add(field);\n        });\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet: fieldNodeSet\n        });\n      }\n      return dataRef;\n    }\n    return incoming;\n  };\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n    }\n    if (isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n    if (typename === void 0) {\n      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n    }\n    var fieldMap = new Map();\n    var policies = this.cache.policies;\n    var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n    (function flatten(selectionSet, inheritedContext) {\n      var visitedNode = limitingTrie.lookup(selectionSet,\n      // Because we take inheritedClientOnly and inheritedDeferred into\n      // consideration here (in addition to selectionSet), it's possible for\n      // the same selection set to be flattened more than once, if it appears\n      // in the query with different @client and/or @directive configurations.\n      inheritedContext.clientOnly, inheritedContext.deferred);\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n      selectionSet.selections.forEach(function (selection) {\n        if (!shouldInclude(selection, context.variables)) return;\n        var clientOnly = inheritedContext.clientOnly,\n          deferred = inheritedContext.deferred;\n        if (\n        // Since the presence of @client or @defer on this field can only\n        // cause clientOnly or deferred to become true, we can skip the\n        // forEach loop if both clientOnly and deferred are already true.\n        !(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {\n          selection.directives.forEach(function (dir) {\n            var name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              var args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || args.if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n        if (isField(selection)) {\n          var existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(14, selection.name.value);\n          }\n          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n          }\n        }\n      });\n    })(selectionSet, context);\n    return fieldMap;\n  };\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n    var _this = this;\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 =\n      // Items in the same position in different arrays are not\n      // necessarily related to each other, so when incoming is an array\n      // we process its elements as if there was no existing data.\n      !isArray(incoming) && (\n      // Likewise, existing must be either a Reference or a StoreObject\n      // in order for its fields to be safe to merge with the fields of\n      // the incoming object.\n      isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      var i_1 = incoming;\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      var changedFields_1;\n      var getValue_1 = function (from, name) {\n        return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n      if (changedFields_1) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n    return incoming;\n  };\n  return StoreWriter;\n}();\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n  return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n  return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  globalThis.__DEV__ !== false && invariant.warn(15, fieldName, parentType, childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", typeDotName, __assign({}, existing), __assign({}, incoming));\n}\n", "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference, DocumentTransform, canonicalStringify, print, cacheSizes } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nvar InMemoryCache = /** @class */function (_super) {\n  __extends(InMemoryCache, _super);\n  function InMemoryCache(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.watches = new Set();\n    _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n    // Override the default value, since InMemoryCache result objects are frozen\n    // in development and expected to remain logically immutable in production.\n    _this.assumeImmutableResults = true;\n    _this.makeVar = makeVar;\n    _this.txCount = 0;\n    _this.config = normalizeConfig(config);\n    _this.addTypename = !!_this.config.addTypename;\n    _this.policies = new Policies({\n      cache: _this,\n      dataIdFromObject: _this.config.dataIdFromObject,\n      possibleTypes: _this.config.possibleTypes,\n      typePolicies: _this.config.typePolicies\n    });\n    _this.init();\n    return _this;\n  }\n  InMemoryCache.prototype.init = function () {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    var rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching\n    });\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n    this.resetResultCache();\n  };\n  InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n    var _this = this;\n    var previousReader = this.storeReader;\n    var fragments = this.config.fragments;\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({\n      cache: this,\n      addTypename: this.addTypename,\n      resultCacheMaxSize: this.config.resultCacheMaxSize,\n      canonizeResults: shouldCanonizeResults(this.config),\n      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,\n      fragments: fragments\n    }), fragments);\n    this.maybeBroadcastWatch = wrap(function (c, options) {\n      return _this.broadcastWatch(c, options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] || 5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */,\n      makeCacheKey: function (c) {\n        // Return a cache key (thus enabling result caching) only if we're\n        // currently using a data store that can track cache dependencies.\n        var store = c.optimistic ? _this.optimisticData : _this.data;\n        if (supportsResultCaching(store)) {\n          var optimistic = c.optimistic,\n            id = c.id,\n            variables = c.variables;\n          return store.makeCacheKey(c.query,\n          // Different watches can have the same query, optimistic\n          // status, rootId, and variables, but if their callbacks are\n          // different, the (identical) result needs to be delivered to\n          // each distinct callback. The easiest way to achieve that\n          // separation is to include c.callback in the cache key for\n          // maybeBroadcastWatch calls. See issue #5733.\n          c.callback, canonicalStringify({\n            optimistic: optimistic,\n            id: id,\n            variables: variables\n          }));\n        }\n      }\n    });\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n      return group.resetCaching();\n    });\n  };\n  InMemoryCache.prototype.restore = function (data) {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  };\n  InMemoryCache.prototype.extract = function (optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return (optimistic ? this.optimisticData : this.data).extract();\n  };\n  InMemoryCache.prototype.read = function (options) {\n    var\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      _a = options.returnPartialData,\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = _a === void 0 ? false : _a;\n    try {\n      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n        store: options.optimistic ? this.optimisticData : this.data,\n        config: this.config,\n        returnPartialData: returnPartialData\n      })).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  };\n  InMemoryCache.prototype.write = function (options) {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.modify = function (options) {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    var store = options.optimistic // Defaults to false.\n    ? this.optimisticData : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.diff = function (options) {\n    return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config\n    }));\n  };\n  InMemoryCache.prototype.watch = function (watch) {\n    var _this = this;\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return function () {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (_this.watches.delete(watch) && !_this.watches.size) {\n        forgetCache(_this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      _this.maybeBroadcastWatch.forget(watch);\n    };\n  };\n  InMemoryCache.prototype.gc = function (options) {\n    var _a;\n    canonicalStringify.reset();\n    print.reset();\n    this.addTypenameTransform.resetCache();\n    (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();\n    var ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  };\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  InMemoryCache.prototype.retain = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  };\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  InMemoryCache.prototype.release = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  };\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  InMemoryCache.prototype.identify = function (object) {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      globalThis.__DEV__ !== false && invariant.warn(e);\n    }\n  };\n  InMemoryCache.prototype.evict = function (options) {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = __assign(__assign({}, options), {\n        id: \"ROOT_QUERY\"\n      });\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.reset = function (options) {\n    var _this = this;\n    this.init();\n    canonicalStringify.reset();\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach(function (watch) {\n        return _this.maybeBroadcastWatch.forget(watch);\n      });\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n    return Promise.resolve();\n  };\n  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  };\n  InMemoryCache.prototype.batch = function (options) {\n    var _this = this;\n    var update = options.update,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      removeOptimistic = options.removeOptimistic,\n      onWatchUpdated = options.onWatchUpdated;\n    var updateResult;\n    var perform = function (layer) {\n      var _a = _this,\n        data = _a.data,\n        optimisticData = _a.optimisticData;\n      ++_this.txCount;\n      if (layer) {\n        _this.data = _this.optimisticData = layer;\n      }\n      try {\n        return updateResult = update(_this);\n      } finally {\n        --_this.txCount;\n        _this.data = data;\n        _this.optimisticData = optimisticData;\n      }\n    };\n    var alreadyDirty = new Set();\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch) {\n          alreadyDirty.add(watch);\n          return false;\n        }\n      }));\n    }\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch, diff) {\n          var result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        }\n      }));\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(function (watch) {\n          return _this.maybeBroadcastWatch.dirty(watch);\n        });\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n    return updateResult;\n  };\n  InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n    return this.batch({\n      update: update,\n      optimistic: optimisticId || optimisticId !== null\n    });\n  };\n  InMemoryCache.prototype.transformDocument = function (document) {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  };\n  InMemoryCache.prototype.fragmentMatches = function (fragment, typename) {\n    return this.policies.fragmentMatches(fragment, typename);\n  };\n  InMemoryCache.prototype.lookupFragment = function (fragmentName) {\n    var _a;\n    return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;\n  };\n  InMemoryCache.prototype.broadcastWatches = function (options) {\n    var _this = this;\n    if (!this.txCount) {\n      this.watches.forEach(function (c) {\n        return _this.maybeBroadcastWatch(c, options);\n      });\n    }\n  };\n  InMemoryCache.prototype.addFragmentsToDocument = function (document) {\n    var fragments = this.config.fragments;\n    return fragments ? fragments.transform(document) : document;\n  };\n  InMemoryCache.prototype.addTypenameToDocument = function (document) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  };\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  InMemoryCache.prototype.broadcastWatch = function (c, options) {\n    var lastDiff = c.lastDiff;\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    var diff = this.diff(c);\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  };\n  return InMemoryCache;\n}(ApolloCache);\nexport { InMemoryCache };\nif (globalThis.__DEV__ !== false) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { visit } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes, getFragmentDefinitions } from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry() {\n  var fragments = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    fragments[_i] = arguments[_i];\n  }\n  return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();\n}\nvar FragmentRegistry = /** @class */function () {\n  // Call `createFragmentRegistry` instead of invoking the\n  // FragmentRegistry constructor directly. This reserves the constructor for\n  // future configuration of the FragmentRegistry.\n  function FragmentRegistry() {\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n    this.registry = Object.create(null);\n    this.resetCaches();\n    if (fragments.length) {\n      this.register.apply(this, fragments);\n    }\n  }\n  FragmentRegistry.prototype.register = function () {\n    var _this = this;\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n    var definitions = new Map();\n    fragments.forEach(function (doc) {\n      getFragmentDefinitions(doc).forEach(function (node) {\n        definitions.set(node.name.value, node);\n      });\n    });\n    definitions.forEach(function (node, name) {\n      if (node !== _this.registry[name]) {\n        _this.registry[name] = node;\n        _this.invalidate(name);\n      }\n    });\n    return this;\n  };\n  // Overridden in the resetCaches method below.\n  FragmentRegistry.prototype.invalidate = function (name) {};\n  FragmentRegistry.prototype.resetCaches = function () {\n    var proto = FragmentRegistry.prototype;\n    this.invalidate = (this.lookup = wrap(proto.lookup.bind(this), {\n      makeCacheKey: function (arg) {\n        return arg;\n      },\n      max: cacheSizes[\"fragmentRegistry.lookup\"] || 1000 /* defaultCacheSizes[\"fragmentRegistry.lookup\"] */\n    })).dirty; // This dirty function is bound to the wrapped lookup method.\n    this.transform = wrap(proto.transform.bind(this), {\n      cache: WeakCache,\n      max: cacheSizes[\"fragmentRegistry.transform\"] || 2000 /* defaultCacheSizes[\"fragmentRegistry.transform\"] */\n    });\n    this.findFragmentSpreads = wrap(proto.findFragmentSpreads.bind(this), {\n      cache: WeakCache,\n      max: cacheSizes[\"fragmentRegistry.findFragmentSpreads\"] || 4000 /* defaultCacheSizes[\"fragmentRegistry.findFragmentSpreads\"] */\n    });\n  };\n  /*\n   * Note:\n   * This method is only memoized so it can serve as a dependency to `tranform`,\n   * so calling `invalidate` will invalidate cache entries for `transform`.\n   */\n  FragmentRegistry.prototype.lookup = function (fragmentName) {\n    return this.registry[fragmentName] || null;\n  };\n  FragmentRegistry.prototype.transform = function (document) {\n    var _this = this;\n    var defined = new Map();\n    getFragmentDefinitions(document).forEach(function (def) {\n      defined.set(def.name.value, def);\n    });\n    var unbound = new Set();\n    var enqueue = function (spreadName) {\n      if (!defined.has(spreadName)) {\n        unbound.add(spreadName);\n      }\n    };\n    var enqueueChildSpreads = function (node) {\n      return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);\n    };\n    enqueueChildSpreads(document);\n    var missing = [];\n    var map = Object.create(null);\n    // This Set forEach loop can be extended during iteration by adding\n    // additional strings to the unbound set.\n    unbound.forEach(function (fragmentName) {\n      var knownFragmentDef = defined.get(fragmentName);\n      if (knownFragmentDef) {\n        enqueueChildSpreads(map[fragmentName] = knownFragmentDef);\n      } else {\n        missing.push(fragmentName);\n        var def = _this.lookup(fragmentName);\n        if (def) {\n          enqueueChildSpreads(map[fragmentName] = def);\n        }\n      }\n    });\n    if (missing.length) {\n      var defsToAppend_1 = [];\n      missing.forEach(function (name) {\n        var def = map[name];\n        if (def) {\n          defsToAppend_1.push(def);\n        }\n      });\n      if (defsToAppend_1.length) {\n        document = __assign(__assign({}, document), {\n          definitions: document.definitions.concat(defsToAppend_1)\n        });\n      }\n    }\n    return document;\n  };\n  FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n    var spreads = Object.create(null);\n    visit(root, {\n      FragmentSpread: function (node) {\n        spreads[node.name.value] = node;\n      }\n    });\n    return spreads;\n  };\n  return FragmentRegistry;\n}();\n"],
  "mappings": "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",
  "names": ["fragment", "ApolloCache", "Cache", "MissingFieldError", "EntityStore", "CacheGroup", "EntityStore", "Root", "Layer", "Stump", "ObjectCanon", "StoreReader", "result", "_a", "cache", "d", "Policies", "existing", "incoming", "supertypeSet", "StoreWriter", "_a", "dataId", "context", "value", "selectionSet", "InMemoryCache", "_a", "FragmentRegistry"]
}
