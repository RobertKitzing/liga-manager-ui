{
  "version": 3,
  "sources": ["../../../../../../node_modules/@apollo/client/link/http/iterators/async.js", "../../../../../../node_modules/@apollo/client/link/http/iterators/nodeStream.js", "../../../../../../node_modules/@apollo/client/link/http/iterators/promise.js", "../../../../../../node_modules/@apollo/client/link/http/iterators/reader.js", "../../../../../../node_modules/@apollo/client/link/http/responseIterator.js", "../../../../../../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js", "../../../../../../node_modules/@apollo/client/link/http/serializeFetchParameter.js", "../../../../../../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js", "../../../../../../node_modules/@apollo/client/link/http/checkFetcher.js", "../../../../../../node_modules/@apollo/client/link/http/createSignalIfSupported.js", "../../../../../../node_modules/@apollo/client/link/http/selectURI.js", "../../../../../../node_modules/@apollo/client/link/http/rewriteURIForGET.js", "../../../../../../node_modules/@apollo/client/link/http/createHttpLink.js", "../../../../../../node_modules/@apollo/client/link/http/HttpLink.js", "../../../../../../node_modules/@apollo/client/core/networkStatus.js", "../../../../../../node_modules/@apollo/client/core/ObservableQuery.js", "../../../../../../node_modules/@apollo/client/core/QueryInfo.js", "../../../../../../node_modules/@apollo/client/core/QueryManager.js", "../../../../../../node_modules/@apollo/client/core/LocalState.js", "../../../../../../node_modules/@apollo/client/core/ApolloClient.js", "../../../../../../node_modules/graphql-tag/lib/index.js", "../../../../../../node_modules/@apollo/client/core/index.js"],
  "sourcesContent": ["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\nexport default function asyncIterator(source) {\n  var _a;\n  var iterator = source[Symbol.asyncIterator]();\n  return _a = {\n    next: function () {\n      return iterator.next();\n    }\n  }, _a[Symbol.asyncIterator] = function () {\n    return this;\n  }, _a;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function nodeStreamIterator(stream) {\n  var cleanup = null;\n  var error = null;\n  var done = false;\n  var data = [];\n  var waiting = [];\n  function onData(chunk) {\n    if (error) return;\n    if (waiting.length) {\n      var shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({\n          value: chunk,\n          done: false\n        });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err) {\n    error = err;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({\n        value: undefined,\n        done: true\n      });\n    });\n    !cleanup || cleanup();\n  }\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n  function getNext() {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({\n        value: data.shift(),\n        done: false\n      });\n      if (done) return resolve({\n        value: undefined,\n        done: true\n      });\n      waiting.push([resolve, reject]);\n    });\n  }\n  var iterator = {\n    next: function () {\n      return getNext();\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function promiseIterator(promise) {\n  var resolved = false;\n  var iterator = {\n    next: function () {\n      if (resolved) return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise.then(function (value) {\n          resolve({\n            value: value,\n            done: false\n          });\n        }).catch(reject);\n      });\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function readerIterator(reader) {\n  var iterator = {\n    next: function () {\n      return reader.read();\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\nfunction isNodeResponse(value) {\n  return !!value.body;\n}\nfunction isReadableStream(value) {\n  return !!value.getReader;\n}\nfunction isAsyncIterableIterator(value) {\n  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);\n}\nfunction isStreamableBlob(value) {\n  return !!value.stream;\n}\nfunction isBlob(value) {\n  return !!value.arrayBuffer;\n}\nfunction isNodeReadableStream(value) {\n  return !!value.pipe;\n}\nexport function responseIterator(response) {\n  var body = response;\n  if (isNodeResponse(response)) body = response.body;\n  if (isAsyncIterableIterator(body)) return asyncIterator(body);\n  if (isReadableStream(body)) return readerIterator(body.getReader());\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator(body.stream().getReader());\n  }\n  if (isBlob(body)) return promiseIterator(body.arrayBuffer());\n  if (isNodeReadableStream(body)) return nodeStreamIterator(body);\n  throw new Error(\"Unknown body type for responseIterator. Please pass a streamable response.\");\n}\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, nextValue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n    var _b, _c;\n    var _d;\n    return __generator(this, function (_e) {\n      switch (_e.label) {\n        case 0:\n          if (TextDecoder === undefined) {\n            throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n          }\n          decoder = new TextDecoder(\"utf-8\");\n          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get(\"content-type\");\n          delimiter = \"boundary=\";\n          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim() : \"-\";\n          boundary = \"\\r\\n--\".concat(boundaryVal);\n          buffer = \"\";\n          iterator = responseIterator(response);\n          running = true;\n          _e.label = 1;\n        case 1:\n          if (!running) return [3 /*break*/, 3];\n          return [4 /*yield*/, iterator.next()];\n        case 2:\n          _a = _e.sent(), value = _a.value, done = _a.done;\n          chunk = typeof value === \"string\" ? value : decoder.decode(value);\n          searchFrom = buffer.length - boundary.length + 1;\n          running = !done;\n          buffer += chunk;\n          bi = buffer.indexOf(boundary, searchFrom);\n          while (bi > -1) {\n            message = void 0;\n            _b = [buffer.slice(0, bi), buffer.slice(bi + boundary.length)], message = _b[0], buffer = _b[1];\n            i = message.indexOf(\"\\r\\n\\r\\n\");\n            headers = parseHeaders(message.slice(0, i));\n            contentType_1 = headers[\"content-type\"];\n            if (contentType_1 && contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n              throw new Error(\"Unsupported patch content type: application/json is required.\");\n            }\n            body = message.slice(i);\n            if (body) {\n              result = parseJsonBody(response, body);\n              if (Object.keys(result).length > 1 || \"data\" in result || \"incremental\" in result || \"errors\" in result || \"payload\" in result) {\n                if (isApolloPayloadResult(result)) {\n                  next = {};\n                  if (\"payload\" in result) {\n                    if (Object.keys(result).length === 1 && result.payload === null) {\n                      return [2 /*return*/];\n                    }\n                    next = __assign({}, result.payload);\n                  }\n                  if (\"errors\" in result) {\n                    next = __assign(__assign({}, next), {\n                      extensions: __assign(__assign({}, \"extensions\" in next ? next.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c))\n                    });\n                  }\n                  nextValue(next);\n                } else {\n                  // for the last chunk with only `hasNext: false`\n                  // we don't need to call observer.next as there is no data/errors\n                  nextValue(result);\n                }\n              } else if (\n              // If the chunk contains only a \"hasNext: false\", we can call\n              // observer.complete() immediately.\n              Object.keys(result).length === 1 && \"hasNext\" in result && !result.hasNext) {\n                return [2 /*return*/];\n              }\n            }\n            bi = buffer.indexOf(boundary);\n          }\n          return [3 /*break*/, 1];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\nexport function parseHeaders(headerText) {\n  var headersInit = {};\n  headerText.split(\"\\n\").forEach(function (line) {\n    var i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      var name_1 = line.slice(0, i).trim().toLowerCase();\n      var value = line.slice(i + 1).trim();\n      headersInit[name_1] = value;\n    }\n  });\n  return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n  if (response.status >= 300) {\n    // Network error\n    var getResult = function () {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n  }\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    var parseError = err;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\nexport function handleError(err, observer) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n  observer.error(err);\n}\nexport function parseAndCheckHttpResponse(operations) {\n  return function (response) {\n    return response.text().then(function (bodyText) {\n      return parseJsonBody(response, bodyText);\n    }).then(function (result) {\n      if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n        // Data error\n        throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ? operations.map(function (op) {\n          return op.operationName;\n        }) : operations.operationName, \"'.\"));\n      }\n      return result;\n    });\n  };\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport var serializeFetchParameter = function (p, label) {\n  var serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    var parseError = newInvariantError(42, label, e.message);\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { print } from \"../../utilities/index.js\";\nvar defaultHttpOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false\n};\nvar defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\"\n};\nvar defaultOptions = {\n  method: \"POST\"\n};\nexport var fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions\n};\nexport var defaultPrinter = function (ast, printer) {\n  return printer(ast);\n};\nexport function selectHttpOptionsAndBody(operation, fallbackConfig) {\n  var configs = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    configs[_i - 2] = arguments[_i];\n  }\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([operation, defaultPrinter], configs, false));\n}\nexport function selectHttpOptionsAndBodyInternal(operation, printer) {\n  var configs = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    configs[_i - 2] = arguments[_i];\n  }\n  var options = {};\n  var http = {};\n  configs.forEach(function (config) {\n    options = __assign(__assign(__assign({}, options), config.options), {\n      headers: __assign(__assign({}, options.headers), config.headers)\n    });\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n    http = __assign(__assign({}, http), config.http);\n  });\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);\n  }\n  //The body depends on the http options\n  var operationName = operation.operationName,\n    extensions = operation.extensions,\n    variables = operation.variables,\n    query = operation.query;\n  var body = {\n    operationName: operationName,\n    variables: variables\n  };\n  if (http.includeExtensions) body.extensions = extensions;\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) body.query = printer(query, print);\n  return {\n    options: options,\n    body: body\n  };\n}\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(headers, preserveHeaderCase) {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    var normalizedHeaders_1 = {};\n    Object.keys(Object(headers)).forEach(function (name) {\n      normalizedHeaders_1[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders_1;\n  }\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  var headerData = {};\n  Object.keys(Object(headers)).forEach(function (name) {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name]\n    };\n  });\n  var normalizedHeaders = {};\n  Object.keys(headerData).forEach(function (name) {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport var checkFetcher = function (fetcher) {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(40);\n  }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport var createSignalIfSupported = function () {\n  if (typeof AbortController === \"undefined\") return {\n    controller: false,\n    signal: false\n  };\n  var controller = new AbortController();\n  var signal = controller.signal;\n  return {\n    controller: controller,\n    signal: signal\n  };\n};\n", "export var selectURI = function (operation, fallbackURI) {\n  var context = operation.getContext();\n  var contextURI = context.uri;\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return fallbackURI || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI, body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  var queryParams = [];\n  var addQueryParam = function (key, value) {\n    queryParams.push(\"\".concat(key, \"=\").concat(encodeURIComponent(value)));\n  };\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    var serializedVariables = void 0;\n    try {\n      serializedVariables = serializeFetchParameter(body.variables, \"Variables map\");\n    } catch (parseError) {\n      return {\n        parseError: parseError\n      };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    var serializedExtensions = void 0;\n    try {\n      serializedExtensions = serializeFetchParameter(body.extensions, \"Extensions map\");\n    } catch (parseError) {\n      return {\n        parseError: parseError\n      };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  var fragment = \"\",\n    preFragment = chosenURI;\n  var fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  var queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  var newURI = preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return {\n    newURI: newURI\n  };\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport { handleError, readMultipartBody, parseAndCheckHttpResponse } from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport { selectHttpOptionsAndBodyInternal, defaultPrinter, fallbackHttpConfig } from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport { maybe, getMainDefinition, removeClientSetsFromDocument } from \"../../utilities/index.js\";\nvar backupFetch = maybe(function () {\n  return fetch;\n});\nexport var createHttpLink = function (linkOptions) {\n  if (linkOptions === void 0) {\n    linkOptions = {};\n  }\n  var _a = linkOptions.uri,\n    uri = _a === void 0 ? \"/graphql\" : _a,\n    // use default global fetch if nothing passed in\n    preferredFetch = linkOptions.fetch,\n    _b = linkOptions.print,\n    print = _b === void 0 ? defaultPrinter : _b,\n    includeExtensions = linkOptions.includeExtensions,\n    preserveHeaderCase = linkOptions.preserveHeaderCase,\n    useGETForQueries = linkOptions.useGETForQueries,\n    _c = linkOptions.includeUnusedVariables,\n    includeUnusedVariables = _c === void 0 ? false : _c,\n    requestOptions = __rest(linkOptions, [\"uri\", \"fetch\", \"print\", \"includeExtensions\", \"preserveHeaderCase\", \"useGETForQueries\", \"includeUnusedVariables\"]);\n  if (globalThis.__DEV__ !== false) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n  var linkConfig = {\n    http: {\n      includeExtensions: includeExtensions,\n      preserveHeaderCase: preserveHeaderCase\n    },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers\n  };\n  return new ApolloLink(function (operation) {\n    var chosenURI = selectURI(operation, uri);\n    var context = operation.getContext();\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    var clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      var _a = context.clientAwareness,\n        name_1 = _a.name,\n        version = _a.version;\n      if (name_1) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name_1;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);\n    var contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders\n    };\n    if (hasDirectives([\"client\"], operation.query)) {\n      var transformedQuery = removeClientSetsFromDocument(operation.query);\n      if (!transformedQuery) {\n        return fromError(new Error(\"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"));\n      }\n      operation.query = transformedQuery;\n    }\n    //uses fallback, link, and then context to build options\n    var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig),\n      options = _b.options,\n      body = _b.body;\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(body.variables, operation.query);\n    }\n    var controller;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n    // If requested, set method to GET if there are no mutations.\n    var definitionIsMutation = function (d) {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    var definitionIsSubscription = function (d) {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));\n    // does not match custom directives beginning with @defer\n    var hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {\n      options.method = \"GET\";\n    }\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      var acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        globalThis.__DEV__ !== false && invariant.warn(41);\n      }\n      if (isSubscription) {\n        acceptHeader += \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n    if (options.method === \"GET\") {\n      var _c = rewriteURIForGET(chosenURI, body),\n        newURI = _c.newURI,\n        parseError = _c.parseError;\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        options.body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n    return new Observable(function (observer) {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      var currentFetch = preferredFetch || maybe(function () {\n        return fetch;\n      }) || backupFetch;\n      var observerNext = observer.next.bind(observer);\n      currentFetch(chosenURI, options).then(function (response) {\n        var _a;\n        operation.setContext({\n          response: response\n        });\n        var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n        if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n          return readMultipartBody(response, observerNext);\n        } else {\n          return parseAndCheckHttpResponse(operation)(response).then(observerNext);\n        }\n      }).then(function () {\n        controller = undefined;\n        observer.complete();\n      }).catch(function (err) {\n        controller = undefined;\n        handleError(err, observer);\n      });\n      return function () {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n", "import { __extends } from \"tslib\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\nvar HttpLink = /** @class */function (_super) {\n  __extends(HttpLink, _super);\n  function HttpLink(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this, createHttpLink(options).request) || this;\n    _this.options = options;\n    return _this;\n  }\n  return HttpLink;\n}(ApolloLink);\nexport { HttpLink };\n", "/**\n * The current status of a query’s execution in our system.\n */\nexport var NetworkStatus;\n(function (NetworkStatus) {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(networkStatus) {\n  return networkStatus ? networkStatus < 7 : false;\n}\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(networkStatus) {\n  return networkStatus === 7 || networkStatus === 8;\n}\n", "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, preventUnhandledRejection } from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nimport { Slot } from \"optimism\";\nvar assign = Object.assign,\n  hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */function (_super) {\n  __extends(ObservableQuery, _super);\n  function ObservableQuery(_a) {\n    var queryManager = _a.queryManager,\n      queryInfo = _a.queryInfo,\n      options = _a.options;\n    var _this = this;\n    var startedInactive = ObservableQuery.inactiveOnCreation.getValue();\n    _this = _super.call(this, function (observer) {\n      if (startedInactive) {\n        queryManager[\"queries\"].set(_this.queryId, queryInfo);\n        startedInactive = false;\n      }\n      // Zen Observable has its own error function, so in order to log correctly\n      // we need to provide a custom error callback.\n      try {\n        var subObserver = observer._subscription._observer;\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch (_a) {}\n      var first = !_this.observers.size;\n      _this.observers.add(observer);\n      // Deliver most recent error or result.\n      var last = _this.last;\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(_this.maskResult(last.result));\n      }\n      // Initiate observation of this query if it hasn't been reported to\n      // the QueryManager yet.\n      if (first) {\n        // Blindly catching here prevents unhandled promise rejections,\n        // and is safe because the ObservableQuery handles this error with\n        // this.observer.error, so we're not just swallowing the error by\n        // ignoring it here.\n        _this.reobserve().catch(function () {});\n      }\n      return function () {\n        if (_this.observers.delete(observer) && !_this.observers.size) {\n          _this.tearDownQuery();\n        }\n      };\n    }) || this;\n    _this.observers = new Set();\n    _this.subscriptions = new Set();\n    _this.dirty = false;\n    // related classes\n    _this.queryInfo = queryInfo;\n    _this.queryManager = queryManager;\n    // active state\n    _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n    _this.isTornDown = false;\n    _this.subscribeToMore = _this.subscribeToMore.bind(_this);\n    _this.maskResult = _this.maskResult.bind(_this);\n    var _b = queryManager.defaultOptions.watchQuery,\n      _c = _b === void 0 ? {} : _b,\n      _d = _c.fetchPolicy,\n      defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n    var _e = options.fetchPolicy,\n      fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      _f = options.initialFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy : _f;\n    _this.options = __assign(__assign({}, options), {\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy: initialFetchPolicy,\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy: fetchPolicy\n    });\n    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n    var opDef = getOperationDefinition(_this.query);\n    _this.queryName = opDef && opDef.name && opDef.name.value;\n    return _this;\n  }\n  Object.defineProperty(ObservableQuery.prototype, \"query\", {\n    // The `query` computed property will always reflect the document transformed\n    // by the last run query. `this.options.query` will always reflect the raw\n    // untransformed query to ensure document transforms with runtime conditionals\n    // are run on the original document.\n    get: function () {\n      return this.lastQuery || this.options.query;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n    // Computed shorthand for this.options.variables, preserved for\n    // backwards compatibility.\n    /**\n     * An object containing the variables that were provided for the query.\n     */\n    get: function () {\n      return this.options.variables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ObservableQuery.prototype.result = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // TODO: this code doesn’t actually make sense insofar as the observer\n      // will never exist in this.observers due how zen-observable wraps observables.\n      // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n      var observer = {\n        next: function (result) {\n          resolve(result);\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          _this.observers.delete(observer);\n          if (!_this.observers.size) {\n            _this.queryManager.removeQuery(_this.queryId);\n          }\n          setTimeout(function () {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject\n      };\n      var subscription = _this.subscribe(observer);\n    });\n  };\n  /** @internal */\n  ObservableQuery.prototype.resetDiff = function () {\n    this.queryInfo.resetDiff();\n  };\n  ObservableQuery.prototype.getCurrentFullResult = function (saveAsLastResult) {\n    if (saveAsLastResult === void 0) {\n      saveAsLastResult = true;\n    }\n    // Use the last result as long as the variables match this.variables.\n    var lastResult = this.getLastResult(true);\n    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;\n    var result = __assign(__assign({}, lastResult), {\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus: networkStatus\n    });\n    var _a = this.options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n    if (\n    // These fetch policies should never deliver data from the cache, unless\n    // redelivering a previously delivered result.\n    skipCacheDataFor(fetchPolicy) ||\n    // If this.options.query has @client(always: true) fields, we cannot\n    // trust diff.result, since it was read from the cache without running\n    // local resolvers (and it's too late to run resolvers now, since we must\n    // return a result synchronously).\n    this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n      // Fall through.\n    } else if (this.waitForOwnResult) {\n      // This would usually be a part of `QueryInfo.getDiff()`.\n      // which we skip in the waitForOwnResult case since we are not\n      // interested in the diff.\n      this.queryInfo[\"updateWatch\"]();\n    } else {\n      var diff = this.queryInfo.getDiff();\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n      if (equal(result.data, {})) {\n        result.data = void 0;\n      }\n      if (diff.complete) {\n        // Similar to setting result.partial to false, but taking advantage of the\n        // falsiness of missing fields.\n        delete result.partial;\n        // If the diff is complete, and we're using a FetchPolicy that\n        // terminates after a complete cache read, we can assume the next result\n        // we receive will have NetworkStatus.ready and !loading.\n        if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n      // We need to check for both both `error` and `errors` field because there\n      // are cases where sometimes `error` is set, but not `errors` and\n      // vice-versa. This will be updated in the next major version when\n      // `errors` is deprecated in favor of `error`.\n      if (result.networkStatus === NetworkStatus.ready && (result.error || result.errors)) {\n        result.networkStatus = NetworkStatus.error;\n      }\n      if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n    return result;\n  };\n  ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n    if (saveAsLastResult === void 0) {\n      saveAsLastResult = true;\n    }\n    return this.maskResult(this.getCurrentFullResult(saveAsLastResult));\n  };\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n    if (!this.last) {\n      return true;\n    }\n    var documentInfo = this.queryManager.getDocumentInfo(this.query);\n    var dataMasking = this.queryManager.dataMasking;\n    var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;\n    var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);\n    return resultIsDifferent || variables && !equal(this.last.variables, variables);\n  };\n  ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n    var last = this.last;\n    if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {\n      return last[key];\n    }\n  };\n  ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n    return this.getLast(\"result\", variablesMustMatch);\n  };\n  ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n    return this.getLast(\"error\", variablesMustMatch);\n  };\n  ObservableQuery.prototype.resetLastResults = function () {\n    delete this.last;\n    this.isTornDown = false;\n  };\n  ObservableQuery.prototype.resetQueryStoreErrors = function () {\n    this.queryManager.resetErrors(this.queryId);\n  };\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  ObservableQuery.prototype.refetch = function (variables) {\n    var _a;\n    var reobserveOptions = {\n      // Always disable polling for refetches.\n      pollInterval: 0\n    };\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    var fetchPolicy = this.options.fetchPolicy;\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n    if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n      var queryDef = getQueryDefinition(this.query);\n      var vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some(function (v) {\n        return v.variable.name.value === \"variables\";\n      })) {\n        globalThis.__DEV__ !== false && invariant.warn(21, variables, ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef);\n      }\n    }\n    if (variables && !equal(this.options.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n    }\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  };\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n    var _this = this;\n    var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), {\n      query: this.options.query\n    }), fetchMoreOptions), {\n      variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables)\n    })), {\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\"\n    });\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n    var qid = this.queryManager.generateQueryId();\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;\n    // Simulate a loading result for the original query with\n    // result.networkStatus === NetworkStatus.fetchMore.\n    var queryInfo = this.queryInfo;\n    var originalNetworkStatus = queryInfo.networkStatus;\n    queryInfo.networkStatus = NetworkStatus.fetchMore;\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.observe();\n    }\n    var updatedQuerySet = new Set();\n    var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;\n    var isCached = this.options.fetchPolicy !== \"no-cache\";\n    if (!isCached) {\n      invariant(updateQuery, 22);\n    }\n    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function (fetchMoreResult) {\n      _this.queryManager.removeQuery(qid);\n      if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n        queryInfo.networkStatus = originalNetworkStatus;\n      }\n      if (isCached) {\n        // Performing this cache update inside a cache.batch transaction ensures\n        // any affected cache.watch watchers are notified at most once about any\n        // updates. Most watchers will be using the QueryInfo class, which\n        // responds to notifications by calling reobserveCacheFirst to deliver\n        // fetchMore cache results back to this ObservableQuery.\n        _this.queryManager.cache.batch({\n          update: function (cache) {\n            var updateQuery = fetchMoreOptions.updateQuery;\n            if (updateQuery) {\n              cache.updateQuery({\n                query: _this.query,\n                variables: _this.variables,\n                returnPartialData: true,\n                optimistic: false\n              }, function (previous) {\n                return updateQuery(previous, {\n                  fetchMoreResult: fetchMoreResult.data,\n                  variables: combinedOptions.variables\n                });\n              });\n            } else {\n              // If we're using a field policy instead of updateQuery, the only\n              // thing we need to do is write the new data to the cache using\n              // combinedOptions.variables (instead of this.variables, which is\n              // what this.updateQuery uses, because it works by abusing the\n              // original field value, keyed by the original variables).\n              cache.writeQuery({\n                query: combinedOptions.query,\n                variables: combinedOptions.variables,\n                data: fetchMoreResult.data\n              });\n            }\n          },\n          onWatchUpdated: function (watch) {\n            // Record the DocumentNode associated with any watched query whose\n            // data were updated by the cache writes above.\n            updatedQuerySet.add(watch.query);\n          }\n        });\n      } else {\n        // There is a possibility `lastResult` may not be set when\n        // `fetchMore` is called which would cause this to crash. This should\n        // only happen if we haven't previously reported a result. We don't\n        // quite know what the right behavior should be here since this block\n        // of code runs after the fetch result has executed on the network.\n        // We plan to let it crash in the meantime.\n        //\n        // If we get bug reports due to the `data` property access on\n        // undefined, this should give us a real-world scenario that we can\n        // use to test against and determine the right behavior. If we do end\n        // up changing this behavior, this may require, for example, an\n        // adjustment to the types on `updateQuery` since that function\n        // expects that the first argument always contains previous result\n        // data, but not `undefined`.\n        var lastResult = _this.getLast(\"result\");\n        var data = updateQuery(lastResult.data, {\n          fetchMoreResult: fetchMoreResult.data,\n          variables: combinedOptions.variables\n        });\n        _this.reportResult(__assign(__assign({}, lastResult), {\n          networkStatus: originalNetworkStatus,\n          loading: isNetworkRequestInFlight(originalNetworkStatus),\n          data: data\n        }), _this.variables);\n      }\n      return _this.maskResult(fetchMoreResult);\n    }).finally(function () {\n      // In case the cache writes above did not generate a broadcast\n      // notification (which would have been intercepted by onWatchUpdated),\n      // likely because the written data were the same as what was already in\n      // the cache, we still want fetchMore to deliver its final loading:false\n      // result with the unchanged data.\n      if (isCached && !updatedQuerySet.has(_this.query)) {\n        _this.reobserveCacheFirst();\n      }\n    });\n  };\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  ObservableQuery.prototype.subscribeToMore = function (options) {\n    var _this = this;\n    var subscription = this.queryManager.startGraphQLSubscription({\n      query: options.document,\n      variables: options.variables,\n      context: options.context\n    }).subscribe({\n      next: function (subscriptionData) {\n        var updateQuery = options.updateQuery;\n        if (updateQuery) {\n          _this.updateQuery(function (previous, updateOptions) {\n            return updateQuery(previous, __assign({\n              subscriptionData: subscriptionData\n            }, updateOptions));\n          });\n        }\n      },\n      error: function (err) {\n        if (options.onError) {\n          options.onError(err);\n          return;\n        }\n        globalThis.__DEV__ !== false && invariant.error(23, err);\n      }\n    });\n    this.subscriptions.add(subscription);\n    return function () {\n      if (_this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  };\n  ObservableQuery.prototype.setOptions = function (newOptions) {\n    return this.reobserve(newOptions);\n  };\n  ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n    var mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n  };\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  ObservableQuery.prototype.setVariables = function (variables) {\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size ? this.result() : Promise.resolve();\n    }\n    this.options.variables = variables;\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n    return this.reobserve({\n      // Reset options.fetchPolicy to its original value.\n      fetchPolicy: this.options.initialFetchPolicy,\n      variables: variables\n    }, NetworkStatus.setVariables);\n  };\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  ObservableQuery.prototype.updateQuery = function (mapFn) {\n    var queryManager = this.queryManager;\n    var _a = queryManager.cache.diff({\n        query: this.options.query,\n        variables: this.variables,\n        returnPartialData: true,\n        optimistic: false\n      }),\n      result = _a.result,\n      complete = _a.complete;\n    var newResult = mapFn(result, {\n      variables: this.variables,\n      complete: !!complete,\n      previousData: result\n    });\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables\n      });\n      queryManager.broadcastQueries();\n    }\n  };\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  ObservableQuery.prototype.startPolling = function (pollInterval) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  };\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  ObservableQuery.prototype.stopPolling = function () {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  };\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  ObservableQuery.prototype.applyNextFetchPolicy = function (reason,\n  // It's possible to use this method to apply options.nextFetchPolicy to\n  // options.fetchPolicy even if options !== this.options, though that happens\n  // most often when the options are temporary, used for only one request and\n  // then thrown away, so nextFetchPolicy may not end up mattering.\n  options) {\n    if (options.nextFetchPolicy) {\n      var _a = options.fetchPolicy,\n        fetchPolicy = _a === void 0 ? \"cache-first\" : _a,\n        _b = options.initialFetchPolicy,\n        initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n          reason: reason,\n          options: options,\n          observable: this,\n          initialFetchPolicy: initialFetchPolicy\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n    return options.fetchPolicy;\n  };\n  ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    var queryInfo = this.queryManager.getOrCreateQuery(this.queryId);\n    queryInfo.setObservableQuery(this);\n    return this.queryManager[\"fetchConcastWithInfo\"](queryInfo, options, newNetworkStatus, query);\n  };\n  // Turns polling on or off based on this.options.pollInterval.\n  ObservableQuery.prototype.updatePolling = function () {\n    var _this = this;\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n    var _a = this,\n      pollingInfo = _a.pollingInfo,\n      pollInterval = _a.options.pollInterval;\n    if (!pollInterval || !this.hasObservers()) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n    invariant(pollInterval, 24);\n    var info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n    var maybeFetch = function () {\n      var _a, _b;\n      if (_this.pollingInfo) {\n        if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n          _this.reobserve({\n            // Most fetchPolicy options don't make sense to use in a polling context, as\n            // users wouldn't want to be polling the cache directly. However, network-only and\n            // no-cache are both useful for when the user wants to control whether or not the\n            // polled results are written to the cache.\n            fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ? \"no-cache\" : \"network-only\"\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n    var poll = function () {\n      var info = _this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n    poll();\n  };\n  ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    var error = this.getLastError();\n    // Preserve this.last.error unless the variables have changed.\n    if (error && this.last && !equal(variables, this.last.variables)) {\n      error = void 0;\n    }\n    return this.last = __assign({\n      result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult),\n      variables: variables\n    }, error ? {\n      error: error\n    } : null);\n  };\n  ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n    var _this = this;\n    this.isTornDown = false;\n    var useDisposableConcast =\n    // Refetching uses a disposable Concast to allow refetches using different\n    // options/variables, without permanently altering the options of the\n    // original ObservableQuery.\n    newNetworkStatus === NetworkStatus.refetch ||\n    // The fetchMore method does not actually call the reobserve method, but,\n    // if it did, it would definitely use a disposable Concast.\n    newNetworkStatus === NetworkStatus.fetchMore ||\n    // Polling uses a disposable Concast so the polling options (which force\n    // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n    newNetworkStatus === NetworkStatus.poll;\n    // Save the old variables, since Object.assign may modify them below.\n    var oldVariables = this.options.variables;\n    var oldFetchPolicy = this.options.fetchPolicy;\n    var mergedOptions = compact(this.options, newOptions || {});\n    var options = useDisposableConcast ?\n    // Disposable Concast fetches receive a shallow copy of this.options\n    // (merged with newOptions), leaving this.options unmodified.\n    mergedOptions : assign(this.options, mergedOptions);\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    var query = this.transformDocument(options.query);\n    this.lastQuery = query;\n    if (!useDisposableConcast) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) &&\n      // Don't mess with the fetchPolicy if it's currently \"standby\".\n      options.fetchPolicy !== \"standby\" && (\n      // If we're changing the fetchPolicy anyway, don't try to change it here\n      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n      options.fetchPolicy === oldFetchPolicy ||\n      // A `nextFetchPolicy` function has even higher priority, though,\n      // so in that case `applyNextFetchPolicy` must be called.\n      typeof options.nextFetchPolicy === \"function\")) {\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n    this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n    var finishWaitingForOwnResult = function () {\n      if (_this.concast === concast) {\n        _this.waitForOwnResult = false;\n      }\n    };\n    var variables = options.variables && __assign({}, options.variables);\n    var _a = this.fetch(options, newNetworkStatus, query),\n      concast = _a.concast,\n      fromLink = _a.fromLink;\n    var observer = {\n      next: function (result) {\n        if (equal(_this.variables, variables)) {\n          finishWaitingForOwnResult();\n          _this.reportResult(result, variables);\n        }\n      },\n      error: function (error) {\n        if (equal(_this.variables, variables)) {\n          // Coming from `getResultsFromLink`, `error` here should always be an `ApolloError`.\n          // However, calling `concast.cancel` can inject another type of error, so we have to\n          // wrap it again here.\n          if (!isApolloError(error)) {\n            error = new ApolloError({\n              networkError: error\n            });\n          }\n          finishWaitingForOwnResult();\n          _this.reportError(error, variables);\n        }\n      }\n    };\n    if (!useDisposableConcast && (fromLink || !this.concast)) {\n      // We use the {add,remove}Observer methods directly to avoid wrapping\n      // observer with an unnecessary SubscriptionObserver object.\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer);\n      }\n      this.concast = concast;\n      this.observer = observer;\n    }\n    concast.addObserver(observer);\n    return concast;\n  };\n  ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n    return preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));\n  };\n  ObservableQuery.prototype.resubscribeAfterError = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    // If `lastError` is set in the current when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore the last value afterwards so that the\n    // subscription has a chance to stay open.\n    var last = this.last;\n    this.resetLastResults();\n    var subscription = this.subscribe.apply(this, args);\n    this.last = last;\n    return subscription;\n  };\n  // (Re)deliver the current result to this.observers without applying fetch\n  // policies or making network requests.\n  ObservableQuery.prototype.observe = function () {\n    this.reportResult(\n    // Passing false is important so that this.getCurrentResult doesn't\n    // save the fetchMore result as this.lastResult, causing it to be\n    // ignored due to the this.isDifferentFromLastResult check in\n    // this.reportResult.\n    this.getCurrentFullResult(false), this.variables);\n  };\n  ObservableQuery.prototype.reportResult = function (result, variables) {\n    var lastError = this.getLastError();\n    var isDifferent = this.isDifferentFromLastResult(result, variables);\n    // Update the last result even when isDifferentFromLastResult returns false,\n    // because the query may be using the @nonreactive directive, and we want to\n    // save the the latest version of any nonreactive subtrees (in case\n    // getCurrentResult is called), even though we skip broadcasting changes.\n    if (lastError || !result.partial || this.options.returnPartialData) {\n      this.updateLastResult(result, variables);\n    }\n    if (lastError || isDifferent) {\n      iterateObserversSafely(this.observers, \"next\", this.maskResult(result));\n    }\n  };\n  ObservableQuery.prototype.reportError = function (error, variables) {\n    // Since we don't get the current result on errors, only the error, we\n    // must mirror the updates that occur in QueryStore.markQueryError here\n    var errorResult = __assign(__assign({}, this.getLastResult()), {\n      error: error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false\n    });\n    this.updateLastResult(errorResult, variables);\n    iterateObserversSafely(this.observers, \"error\", this.last.error = error);\n  };\n  ObservableQuery.prototype.hasObservers = function () {\n    return this.observers.size > 0;\n  };\n  ObservableQuery.prototype.tearDownQuery = function () {\n    if (this.isTornDown) return;\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  };\n  ObservableQuery.prototype.transformDocument = function (document) {\n    return this.queryManager.transform(document);\n  };\n  ObservableQuery.prototype.maskResult = function (result) {\n    return result && \"data\" in result ? __assign(__assign({}, result), {\n      data: this.queryManager.maskOperation({\n        document: this.query,\n        data: result.data,\n        fetchPolicy: this.options.fetchPolicy,\n        id: this.queryId\n      })\n    }) : result;\n  };\n  /** @internal */\n  ObservableQuery.prototype.resetNotifications = function () {\n    this.cancelNotifyTimeout();\n    this.dirty = false;\n  };\n  ObservableQuery.prototype.cancelNotifyTimeout = function () {\n    if (this.notifyTimeout) {\n      clearTimeout(this.notifyTimeout);\n      this.notifyTimeout = void 0;\n    }\n  };\n  /** @internal */\n  ObservableQuery.prototype.scheduleNotify = function () {\n    var _this = this;\n    if (this.dirty) return;\n    this.dirty = true;\n    if (!this.notifyTimeout) {\n      this.notifyTimeout = setTimeout(function () {\n        return _this.notify();\n      }, 0);\n    }\n  };\n  /** @internal */\n  ObservableQuery.prototype.notify = function () {\n    this.cancelNotifyTimeout();\n    if (this.dirty) {\n      if (this.options.fetchPolicy == \"cache-only\" || this.options.fetchPolicy == \"cache-and-network\" || !isNetworkRequestInFlight(this.queryInfo.networkStatus)) {\n        var diff = this.queryInfo.getDiff();\n        if (diff.fromOptimisticTransaction) {\n          // If this diff came from an optimistic transaction, deliver the\n          // current cache data to the ObservableQuery, but don't perform a\n          // reobservation, since oq.reobserveCacheFirst might make a network\n          // request, and we never want to trigger network requests in the\n          // middle of optimistic updates.\n          this.observe();\n        } else {\n          // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n          // using a temporary fetch policy of \"cache-first\", so complete cache\n          // results have a chance to be delivered without triggering additional\n          // network requests, even when options.fetchPolicy is \"network-only\"\n          // or \"cache-and-network\". All other fetch policies are preserved by\n          // this method, and are handled by calling oq.reobserve(). If this\n          // reobservation is spurious, isDifferentFromLastResult still has a\n          // chance to catch it before delivery to ObservableQuery subscribers.\n          this.reobserveCacheFirst();\n        }\n      }\n    }\n    this.dirty = false;\n  };\n  // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n  // delivery of any new data from the cache, possibly falling back to the network\n  // if any cache data are missing. This allows _complete_ cache results to be\n  // delivered without also kicking off unnecessary network requests when\n  // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n  // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n  // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n  ObservableQuery.prototype.reobserveCacheFirst = function () {\n    var _a = this.options,\n      fetchPolicy = _a.fetchPolicy,\n      nextFetchPolicy = _a.nextFetchPolicy;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n      return this.reobserve({\n        fetchPolicy: \"cache-first\",\n        // Use a temporary nextFetchPolicy function that replaces itself with the\n        // previous nextFetchPolicy value and returns the original fetchPolicy.\n        nextFetchPolicy: function (currentFetchPolicy, context) {\n          // Replace this nextFetchPolicy function in the options object with the\n          // original this.options.nextFetchPolicy value.\n          this.nextFetchPolicy = nextFetchPolicy;\n          // If the original nextFetchPolicy value was a function, give it a\n          // chance to decide what happens here.\n          if (typeof this.nextFetchPolicy === \"function\") {\n            return this.nextFetchPolicy(currentFetchPolicy, context);\n          }\n          // Otherwise go back to the original this.options.fetchPolicy.\n          return fetchPolicy;\n        }\n      });\n    }\n    return this.reobserve();\n  };\n  /**\n   * @internal\n   * A slot used by the `useQuery` hook to indicate that `client.watchQuery`\n   * should not register the query immediately, but instead wait for the query to\n   * be started registered with the `QueryManager` when `useSyncExternalStore`\n   * actively subscribes to it.\n   */\n  ObservableQuery.inactiveOnCreation = new Slot();\n  return ObservableQuery;\n}(Observable);\nexport { ObservableQuery };\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\nfunction defaultSubscriptionObserverErrorCallback(error) {\n  globalThis.__DEV__ !== false && invariant.error(25, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n  if (globalThis.__DEV__ !== false && missing) {\n    globalThis.__DEV__ !== false && invariant.debug(26, missing);\n  }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n  return fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\" || fetchPolicy === \"standby\";\n}\n", "import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport { isNonEmptyArray, graphQLResultHasError, canUseWeakMap } from \"../utilities/index.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nvar destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n  var original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(cache,\n      // The %1e15 allows the count to wrap around to 0 safely every\n      // quadrillion evictions, so there's no risk of overflow. To be\n      // clear, this is more of a pedantic principle than something\n      // that matters in any conceivable practical scenario.\n      (destructiveMethodCounts.get(cache) + 1) % 1e15);\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nvar QueryInfo = /** @class */function () {\n  function QueryInfo(queryManager, queryId) {\n    if (queryId === void 0) {\n      queryId = queryManager.generateQueryId();\n    }\n    this.queryId = queryId;\n    this.document = null;\n    this.lastRequestId = 1;\n    this.stopped = false;\n    this.observableQuery = null;\n    var cache = this.cache = queryManager.cache;\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n  QueryInfo.prototype.init = function (query) {\n    var networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n      // Ensure we don't continue to receive cache updates for old variables\n      this.cancel();\n    }\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus: networkStatus\n    });\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n    return this;\n  };\n  QueryInfo.prototype.resetDiff = function () {\n    this.lastDiff = void 0;\n  };\n  QueryInfo.prototype.getDiff = function () {\n    var options = this.getDiffOptions();\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n    this.updateWatch(this.variables);\n    var oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return {\n        complete: false\n      };\n    }\n    var diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  };\n  QueryInfo.prototype.updateLastDiff = function (diff, options) {\n    this.lastDiff = diff ? {\n      diff: diff,\n      options: options || this.getDiffOptions()\n    } : void 0;\n  };\n  QueryInfo.prototype.getDiffOptions = function (variables) {\n    var _a;\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    return {\n      query: this.document,\n      variables: variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults\n    };\n  };\n  QueryInfo.prototype.setDiff = function (diff) {\n    var _a, _b;\n    var oldDiff = this.lastDiff && this.lastDiff.diff;\n    // If we are trying to deliver an incomplete cache result, we avoid\n    // reporting it if the query has errored, otherwise we let the broadcast try\n    // and repair the partial result by refetching the query. This check avoids\n    // a situation where a query that errors and another succeeds with\n    // overlapping data does not report the partial data result to the errored\n    // query.\n    //\n    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n    // information on this issue.\n    if (diff && !diff.complete && ((_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.getLastError())) {\n      return;\n    }\n    this.updateLastDiff(diff);\n    if (!equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      (_b = this.observableQuery) === null || _b === void 0 ? void 0 : _b[\"scheduleNotify\"]();\n    }\n  };\n  QueryInfo.prototype.setObservableQuery = function (oq) {\n    if (oq === this.observableQuery) return;\n    this.observableQuery = oq;\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n    }\n  };\n  QueryInfo.prototype.stop = function () {\n    var _a;\n    if (!this.stopped) {\n      this.stopped = true;\n      // Cancel the pending notify timeout\n      (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a[\"resetNotifications\"]();\n      this.cancel();\n      var oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  };\n  QueryInfo.prototype.cancel = function () {\n    var _a;\n    (_a = this.cancelWatch) === null || _a === void 0 ? void 0 : _a.call(this);\n    this.cancelWatch = void 0;\n  };\n  QueryInfo.prototype.updateWatch = function (variables) {\n    var _this = this;\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    var oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n    var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), {\n      watcher: this,\n      callback: function (diff) {\n        return _this.setDiff(diff);\n      }\n    });\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancelWatch = this.cache.watch(this.lastWatch = watchOptions);\n    }\n  };\n  QueryInfo.prototype.resetLastWrite = function () {\n    this.lastWrite = void 0;\n  };\n  QueryInfo.prototype.shouldWrite = function (result, variables) {\n    var lastWrite = this.lastWrite;\n    return !(lastWrite &&\n    // If cache.evict has been called since the last time we wrote this\n    // data into the cache, there's a chance writing this result into\n    // the cache will repair what was evicted.\n    lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));\n  };\n  QueryInfo.prototype.markResult = function (result, document, options, cacheWriteBehavior) {\n    var _this = this;\n    var _a;\n    var merger = new DeepMerger();\n    var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a[\"resetNotifications\"]();\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      var mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      var diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n    this.graphQLErrors = graphQLErrors;\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff({\n        result: result.data,\n        complete: true\n      }, this.getDiffOptions(options.variables));\n    } else if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction(function (cache) {\n          if (_this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */\n            });\n            _this.lastWrite = {\n              result: result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(_this.cache)\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (_this.lastDiff && _this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = _this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n          var diffOptions = _this.getDiffOptions(options.variables);\n          var diff = cache.diff(diffOptions);\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!_this.stopped && equal(_this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            _this.updateWatch(options.variables);\n          }\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          _this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  };\n  QueryInfo.prototype.markReady = function () {\n    this.networkError = null;\n    return this.networkStatus = NetworkStatus.ready;\n  };\n  QueryInfo.prototype.markError = function (error) {\n    var _a;\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n    (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a[\"resetNotifications\"]();\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n    return error;\n  };\n  return QueryInfo;\n}();\nexport { QueryInfo };\nexport function shouldWriteResult(result, errorPolicy) {\n  if (errorPolicy === void 0) {\n    errorPolicy = \"none\";\n  }\n  var ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  var writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nvar QueryManager = /** @class */function () {\n  function QueryManager(options) {\n    var _this = this;\n    this.clientAwareness = {};\n    // All the queries that the QueryManager is currently managing (not\n    // including mutations and subscriptions).\n    this.queries = new Map();\n    // Maps from queryId strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.fetchCancelFns = new Map();\n    this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.inFlightLinkObservables = new Trie(false);\n    this.noCacheWarningsByQueryId = new Set();\n    var defaultDocumentTransform = new DocumentTransform(function (document) {\n      return _this.cache.transformDocument(document);\n    },\n    // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    var documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)\n    // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(newInvariantError(27));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n      var _c, _d;\n      var mutation = _b.mutation,\n        variables = _b.variables,\n        optimisticResponse = _b.optimisticResponse,\n        updateQueries = _b.updateQueries,\n        _e = _b.refetchQueries,\n        refetchQueries = _e === void 0 ? [] : _e,\n        _f = _b.awaitRefetchQueries,\n        awaitRefetchQueries = _f === void 0 ? false : _f,\n        updateWithProxyFn = _b.update,\n        onQueryUpdated = _b.onQueryUpdated,\n        _g = _b.fetchPolicy,\n        fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g,\n        _h = _b.errorPolicy,\n        errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h,\n        keepRootFields = _b.keepRootFields,\n        context = _b.context;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            invariant(mutation, 28);\n            invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n            mutationId = this.generateMutationId();\n            mutation = this.cache.transformForLink(this.transform(mutation));\n            hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _j.sent();\n            _j.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n              mutationId: mutationId,\n              document: mutation,\n              variables: variables,\n              fetchPolicy: fetchPolicy,\n              errorPolicy: errorPolicy,\n              context: context,\n              updateQueries: updateQueries,\n              update: updateWithProxyFn,\n              keepRootFields: keepRootFields\n            });\n            this.broadcastQueries();\n            self = this;\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: isOptimistic ? optimisticResponse : void 0\n              }), variables, {}, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n                var storeResult = __assign({}, result);\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n                if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: isOptimistic ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries();\n                  // Since mutations might receive multiple payloads from the\n                  // ApolloLink chain (e.g. when used with @defer),\n                  // we resolve with a SingleExecutionResult or after the final\n                  // ExecutionPatchResult has arrived and we have assembled the\n                  // multipart response into a single result.\n                  if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                    resolve(__assign(__assign({}, storeResult), {\n                      data: self.maskOperation({\n                        document: mutation,\n                        data: storeResult.data,\n                        fetchPolicy: fetchPolicy,\n                        id: mutationId\n                      })\n                    }));\n                  }\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (isOptimistic) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          // Read the current query result from the store.\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n    if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          var update = mutation.update;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: _this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          }\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                  DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n    return Promise.resolve(result);\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, {\n      IGNORE: IGNORE\n    }) : optimisticResponse;\n    if (data === IGNORE) {\n      return false;\n    }\n    this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        globalThis.__DEV__ !== false && invariant.error(error);\n      }\n    }, mutation.mutationId);\n    return true;\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(this.getOrCreateQuery(queryId), options, networkStatus).concast.promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    return this.documentTransform.transformDocument(document);\n  };\n  QueryManager.prototype.getDocumentInfo = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        defaultVars: getDefaultValues(getOperationDefinition(document)),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: __assign(__assign({}, document), {\n          definitions: document.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    var query = this.transform(options.query);\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    observable[\"lastQuery\"] = query;\n    if (!ObservableQuery[\"inactiveOnCreation\"].getValue()) {\n      this.queries.set(observable.queryId, queryInfo);\n    }\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n    invariant(options.query, 30);\n    invariant(options.query.kind === \"Document\", 31);\n    invariant(!options.returnPartialData, 32);\n    invariant(!options.pollInterval, 33);\n    var query = this.transform(options.query);\n    return this.fetchQuery(queryId, __assign(__assign({}, options), {\n      query: query\n    })).then(function (result) {\n      return result && __assign(__assign({}, result), {\n        data: _this.maskOperation({\n          document: query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: queryId\n        })\n      });\n    }).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    }\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(34));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    // begin removing data from the store\n    return this.cache.reset(options);\n  };\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n    if (include === void 0) {\n      include = \"active\";\n    }\n    var queries = new Map();\n    var queryNames = new Map();\n    var queryNamesAndQueryStrings = new Map();\n    var legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          var queryString = print(_this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n        document = _a.document;\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n        var queryName = oq.queryName,\n          fetchPolicy = oq.options.fetchPolicy;\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n        if (include === \"active\" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(print(document))) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        var queryInfo = _this.getOrCreateQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n    if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach(function (included, nameOrQueryString) {\n        if (!included) {\n          var queryName = queryNames.get(nameOrQueryString);\n          if (queryName) {\n            globalThis.__DEV__ !== false && invariant.warn(35, queryName);\n          } else {\n            globalThis.__DEV__ !== false && invariant.warn(36);\n          }\n        }\n      });\n    }\n    return queries;\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      (_this.queries.get(queryId) || observableQuery[\"queryInfo\"]).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (options) {\n    var _this = this;\n    var query = options.query,\n      variables = options.variables;\n    var fetchPolicy = options.fetchPolicy,\n      _a = options.errorPolicy,\n      errorPolicy = _a === void 0 ? \"none\" : _a,\n      _b = options.context,\n      context = _b === void 0 ? {} : _b,\n      _c = options.extensions,\n      extensions = _c === void 0 ? {} : _c;\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n        return result;\n      });\n    };\n    if (this.getDocumentInfo(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    var _a;\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      (_a = this.queries.get(queryId)) === null || _a === void 0 ? void 0 : _a.stop();\n      this.queries.delete(queryId);\n    }\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      var _a;\n      return (_a = info.observableQuery) === null || _a === void 0 ? void 0 : _a[\"notify\"]();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions,\n  // Prefer context.queryDeduplication if specified.\n  deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var _b = this.getDocumentInfo(query),\n      serverQuery = _b.serverQuery,\n      clientQuery = _b.clientQuery;\n    if (serverQuery) {\n      var _c = this,\n        inFlightLinkObservables_1 = _c.inFlightLinkObservables,\n        link = _c.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        })),\n        extensions: extensions\n      };\n      context = operation.context;\n      if (deduplication) {\n        var printedServerQuery_1 = print(serverQuery);\n        var varJson_1 = canonicalStringify(variables);\n        var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n        observable = entry.observable;\n        if (!observable) {\n          var concast_1 = new Concast([execute(link, operation)]);\n          observable = entry.observable = concast_1;\n          concast_1.beforeNext(function cb(method, arg) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast_1.beforeNext(cb);\n            } else {\n              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    var linkDocument = this.cache.transformForLink(options.query);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      var errorPolicy = options.errorPolicy;\n      // If we interrupted this request by calling getResultsFromLink again\n      // with the same QueryInfo object, we ignore the old results.\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && errorPolicy === \"none\") {\n          // Throwing here effectively calls observer.error.\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        }\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      };\n      // In the case we start multiple network requests simulatenously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n      if (hasErrors && errorPolicy === \"none\") {\n        aqr.data = void 0;\n      }\n      if (hasErrors && errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      // Avoid storing errors from older interrupted queries.\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchConcastWithInfo = function (queryInfo, options,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus, query) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    if (query === void 0) {\n      query = options.query;\n    }\n    var variables = this.getVariables(query, options.variables);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function (variables) {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n      if (\n      // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\" &&\n      // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n      // this is another way to detect when nothing was done/fetched.\n      sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return sourcesWithInfo;\n    };\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    var cleanupCancelFn = function () {\n      return _this.fetchCancelFns.delete(queryInfo.queryId);\n    };\n    this.fetchCancelFns.set(queryInfo.queryId, function (reason) {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      }));\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n    var updateCache = _a.updateCache,\n      include = _a.include,\n      _b = _a.optimistic,\n      optimistic = _b === void 0 ? false : _b,\n      _c = _a.removeOptimistic,\n      removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n      onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: (_this.queries.get(queryId) || oq[\"queryInfo\"]).getDiff()\n        });\n      });\n    }\n    var results = new Map();\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n          lastDiff = _a.lastDiff,\n          diff = _a.diff;\n        var result;\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = _this.cache.diff(oq[\"queryInfo\"][\"getDiffOptions\"]());\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  };\n  QueryManager.prototype.maskOperation = function (options) {\n    var _a, _b, _c;\n    var document = options.document,\n      data = options.data;\n    if (globalThis.__DEV__ !== false) {\n      var fetchPolicy = options.fetchPolicy,\n        id = options.id;\n      var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n      var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {\n        this.noCacheWarningsByQueryId.add(operationId);\n        globalThis.__DEV__ !== false && invariant.warn(37, (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\"));\n      }\n    }\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  };\n  QueryManager.prototype.maskFragment = function (options) {\n    var data = options.data,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus) {\n    var _this = this;\n    var query = _a.query,\n      variables = _a.variables,\n      fetchPolicy = _a.fetchPolicy,\n      refetchWritePolicy = _a.refetchWritePolicy,\n      errorPolicy = _a.errorPolicy,\n      returnPartialData = _a.returnPartialData,\n      context = _a.context,\n      notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n    var readCache = function () {\n      return queryInfo.getDiff();\n    };\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n      return fromData(data);\n    };\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n    // Watched queries must opt into overwriting existing data on refetch,\n    // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n    : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */ : 2 /* CacheWriteBehavior.MERGE */;\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        query: query,\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n  QueryManager.prototype.getOrCreateQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign(__assign({}, this.defaultContext), newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = /** @class */function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n      client = _a.client,\n      resolvers = _a.resolvers,\n      fragmentMatcher = _a.fragmentMatcher;\n    this.selectionsToResolveCache = new WeakMap();\n    this.cache = cache;\n    if (client) {\n      this.client = client;\n    }\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  LocalState.prototype.runResolvers = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var document = _b.document,\n        remoteResult = _b.remoteResult,\n        context = _b.context,\n        variables = _b.variables,\n        _c = _b.onlyRunForcedResolvers,\n        onlyRunForcedResolvers = _c === void 0 ? false : _c;\n      return __generator(this, function (_d) {\n        if (document) {\n          return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n        return [2 /*return*/, remoteResult];\n      });\n    });\n  };\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  };\n  // Server queries are stripped of all @client based selection sets.\n  LocalState.prototype.serverQuery = function (document) {\n    return removeClientSetsFromDocument(document);\n  };\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return __assign(__assign({}, context), {\n      cache: cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: function (obj) {\n        return cache.identify(obj);\n      }\n    });\n  };\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  LocalState.prototype.addExportedVariables = function (document_1) {\n    return __awaiter(this, arguments, void 0, function (document, variables, context) {\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (context === void 0) {\n        context = {};\n      }\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n        return [2 /*return*/, __assign({}, variables)];\n      });\n    });\n  };\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === \"always\" && arg.value.kind === \"BooleanValue\" && arg.value.value === true;\n            });\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n  // Query the cache and return matching data.\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n  LocalState.prototype.resolveDocument = function (document_1, rootValue_1) {\n    return __awaiter(this, arguments, void 0, function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n      var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n      if (context === void 0) {\n        context = {};\n      }\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (fragmentMatcher === void 0) {\n        fragmentMatcher = function () {\n          return true;\n        };\n      }\n      if (onlyRunForcedResolvers === void 0) {\n        onlyRunForcedResolvers = false;\n      }\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : \"Query\";\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          selectionsToResolve: selectionsToResolve,\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        isClientFieldDescendant = false;\n        return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n      var _this = this;\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n        execute = function (selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                // Skip selections without @client directives\n                // (still processing if one of the ancestors or one of the child fields has @client directive)\n                return [2 /*return*/];\n              }\n              if (!shouldInclude(selection, variables)) {\n                // Skip this entirely.\n                return [2 /*return*/];\n              }\n              if (isField(selection)) {\n                return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n                  if (typeof fieldResult !== \"undefined\") {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                // This is a named fragment.\n                fragment = fragmentMap[selection.name.value];\n                invariant(fragment, 19, selection.name.value);\n              }\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n              return [2 /*return*/];\n            });\n          });\n        };\n        return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (!rootValue) {\n          return [2 /*return*/, null];\n        }\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n        // Usually all local resolvers are run when passing through here, but\n        // if we've specifically identified that we only want to run forced\n        // resolvers (that is, resolvers for fields marked with\n        // `@client(always: true)`), then we'll skip running non-forced resolvers.\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n            if (resolve) {\n              resultPromise = Promise.resolve(\n              // In case the resolve function accesses reactive variables,\n              // set cacheSlot to the current cache instance.\n              cacheSlot.withValue(this.cache, resolve, [rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n        return [2 /*return*/, resultPromise.then(function (result) {\n          var _a, _b;\n          if (result === void 0) {\n            result = defaultResult;\n          }\n          // If an @export directive is associated with the current field, store\n          // the `as` export variable name and current result for later use.\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === \"export\" && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n          // Handle all scalar types here.\n          if (!field.selectionSet) {\n            return result;\n          }\n          // From here down, the field has a selection set, which means it's trying\n          // to query a GraphQLObjectType.\n          if (result == null) {\n            // Basically any field in a GraphQL response can be null, or missing\n            return result;\n          }\n          var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) {\n            return d.name.value === \"client\";\n          })) !== null && _b !== void 0 ? _b : false;\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n          }\n          // Returned value is an object, and the query has a sub-selection. Recurse.\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n    var _this = this;\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse.\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n      }\n      // This is an object, run the selection set on it.\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n      }\n    }));\n  };\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n    var isSingleASTNode = function (node) {\n      return !Array.isArray(node);\n    };\n    var selectionsToResolveCache = this.selectionsToResolveCache;\n    function collectByDefinition(definitionNode) {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        var matches_1 = new Set();\n        selectionsToResolveCache.set(definitionNode, matches_1);\n        visit(definitionNode, {\n          Directive: function (node, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread: function (spread, _, __, ___, ancestors) {\n            var fragment = fragmentMap[spread.name.value];\n            invariant(fragment, 20, spread.name.value);\n            var fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n              matches_1.add(spread);\n              fragmentSelections.forEach(function (selection) {\n                matches_1.add(selection);\n              });\n            }\n          }\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode);\n    }\n    return collectByDefinition(mainDefinition);\n  };\n  return LocalState;\n}();\nexport { LocalState };\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nexport { mergeOptions };\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nvar ApolloClient = /** @class */function () {\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  function ApolloClient(options) {\n    var _this = this;\n    var _a;\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n    if (!options.cache) {\n      throw newInvariantError(16);\n    }\n    var uri = options.uri,\n      credentials = options.credentials,\n      headers = options.headers,\n      cache = options.cache,\n      documentTransform = options.documentTransform,\n      _b = options.ssrMode,\n      ssrMode = _b === void 0 ? false : _b,\n      _c = options.ssrForceFetchDelay,\n      ssrForceFetchDelay = _c === void 0 ? 0 : _c,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools = options.connectToDevTools,\n      _d = options.queryDeduplication,\n      queryDeduplication = _d === void 0 ? true : _d,\n      defaultOptions = options.defaultOptions,\n      defaultContext = options.defaultContext,\n      _e = options.assumeImmutableResults,\n      assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e,\n      resolvers = options.resolvers,\n      typeDefs = options.typeDefs,\n      fragmentMatcher = options.fragmentMatcher,\n      clientAwarenessName = options.name,\n      clientAwarenessVersion = options.version,\n      devtools = options.devtools,\n      dataMasking = options.dataMasking;\n    var link = options.link;\n    if (!link) {\n      link = uri ? new HttpLink({\n        uri: uri,\n        credentials: credentials,\n        headers: headers\n      }) : ApolloLink.empty();\n    }\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = __assign(__assign({}, devtools), {\n      enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools\n    });\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;\n    }\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext: defaultContext,\n      documentTransform: documentTransform,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: clientAwarenessName,\n        version: clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: this.devtoolsConfig.enabled ? function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.getQueryStore(),\n              mutations: _this.queryManager.mutationStore || {}\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      } : void 0\n    });\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n  ApolloClient.prototype.connectToDevTools = function () {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    var windowWithDevTools = window;\n    var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n      hasSuggestedDevtools = true;\n      if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {\n        setTimeout(function () {\n          if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            var nav = window.navigator;\n            var ua = nav && nav.userAgent;\n            var url = void 0;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n            }\n          }\n        }, 10000);\n      }\n    }\n  };\n  Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n    /**\n     * The `DocumentTransform` used to modify GraphQL documents before a request\n     * is made. If a custom `DocumentTransform` is not provided, this will be the\n     * default document transform.\n     */\n    get: function () {\n      return this.queryManager.documentTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (this.disableNetworkFetches && (options.fetchPolicy === \"network-only\" || options.fetchPolicy === \"cache-and-network\")) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n    return this.queryManager.watchQuery(options);\n  };\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n    invariant(options.fetchPolicy !== \"cache-and-network\", 17);\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n    return this.queryManager.query(options);\n  };\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate(options);\n  };\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  ApolloClient.prototype.subscribe = function (options) {\n    var _this = this;\n    var id = this.queryManager.generateQueryId();\n    return this.queryManager.startGraphQLSubscription(options).map(function (result) {\n      return __assign(__assign({}, result), {\n        data: _this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: id\n        })\n      });\n    });\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readQuery(options, optimistic);\n  };\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n  ApolloClient.prototype.watchFragment = function (options) {\n    var _a;\n    return this.cache.watchFragment(__assign(__assign({}, options), (_a = {}, _a[Symbol.for(\"apollo.dataMasking\")] = this.queryManager.dataMasking, _a)));\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readFragment(options, optimistic);\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  ApolloClient.prototype.writeQuery = function (options) {\n    var ref = this.cache.writeQuery(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  ApolloClient.prototype.writeFragment = function (options) {\n    var ref = this.cache.writeFragment(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: false\n      });\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: true\n      });\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  ApolloClient.prototype.refetchQueries = function (options) {\n    var map = this.queryManager.refetchQueries(options);\n    var queries = [];\n    var results = [];\n    map.forEach(function (result, obsQuery) {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n    var result = Promise.all(results);\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch(function (error) {\n      globalThis.__DEV__ !== false && invariant.debug(18, error);\n    });\n    return result;\n  };\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  ApolloClient.prototype.getObservableQueries = function (include) {\n    if (include === void 0) {\n      include = \"active\";\n    }\n    return this.queryManager.getObservableQueries(include);\n  };\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n  /**\n   * Add additional local resolvers.\n   */\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n  /**\n   * Set (override existing) local resolvers.\n   */\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n  /**\n   * Get all registered local resolvers.\n   */\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  ApolloClient.prototype.setLink = function (newLink) {\n    this.link = this.queryManager.link = newLink;\n  };\n  Object.defineProperty(ApolloClient.prototype, \"defaultContext\", {\n    get: function () {\n      return this.queryManager.defaultContext;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ApolloClient;\n}();\nexport { ApolloClient };\nif (globalThis.__DEV__ !== false) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n", "import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n      sourceKeySet.add(sourceKey);\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n  return doc;\n}\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n  return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n", "/* Core */\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\nexport { Cache, ApolloCache, InMemoryCache, MissingFieldError, defaultDataIdFromObject, makeVar } from \"../cache/index.js\";\n/* Link */\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport { fromError, toPromise, fromPromise, throwServerError } from \"../link/utils/index.js\";\nexport { DocumentTransform, Observable, isReference, makeReference } from \"../utilities/index.js\";\n/* Supporting */\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(globalThis.__DEV__ !== false ? \"log\" : \"silent\");\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport { gql, resetCaches, disableFragmentWarnings, enableExperimentalFragmentVariables, disableExperimentalFragmentVariables } from \"graphql-tag\";\n"],
  "mappings": "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",
  "names": ["print", "_a", "version", "_b", "_c", "parseError", "HttpLink", "NetworkStatus", "hasOwnProperty", "ObservableQuery", "_a", "updateQuery", "info", "QueryInfo", "diff", "hasOwnProperty", "QueryManager", "hasClientExports", "cache", "diff", "result", "variables", "sourcesWithInfo", "_a", "networkStatus", "data", "LocalState", "execute", "_a", "node", "ApolloClient", "defaultOptions", "result"]
}
